2217번 로프

몇개의 로프를 사용해 최대 무게를 들어라.

각 로프는 들 수 있는 무게가 있고, 로프를 다 쓰지 않아도 상관없이
무게를 크게 만들 수 있으면 된다.

일단 어떻게 풀었냐면, 어차피 각 로프가 들 수 있는 최대 무게만큼을 들어야 하므로
로프가 견딜 무게를 받고 정렬한 뒤, 가장 낮은 순부터 배열을 한번 순회하면서
w/k가 로프의 현재 무게일 때 견딜 수 있는 애들은 뒤로 갈수록 있으니까
그냥 list[i]*(N-i)를 해서 무게의 최댓값을 구한 뒤, 뒷 값들과 비교한다.
여기서 값이 다 같을 경우는 앞에서 이미 Count 했기 때문에 답이 정상적으로 나오고,
n개의 로프가 같을 경우도 앞에서 계산을 하기 때문에 그럼.
단, 의미없는 계산이 되긴 해서 이 부분을 개선할 수 있다면 좋겠음.

-----------------------------------------------------------------------------------------------

2869번 달팽이는 올라가고 싶다.

사실 구하는건 어렵지 않다. 문제는 시간과 올라가는 나무의 높이가 터무니없이 크다는 점이다.
그래서 반복문 없이 써서 구했는데 0.15초의 벽에 막혀버렸다.
무슨 if문 2개인데 시간 초과가 난다는게 좀 이해가 안가긴 하는데, 틀렸다고 하니깐 생각을 좀 해봐야할 것 같다.
음... 일단
내가 생각한 부분도 맞는거 같은데, 시간 초과가 났다.
그래서 다르게 생각해봤는데, 그냥 무지성으로 생각하다가 (V-B)/(A-B)로 계산을 했는데
값이 나머지가 있으면 +1, 없으면 그 값이 곧 걸리는 시간이더라.

스쳐지나가듯이 그냥 적었는데 맞아서 놀램.
원리는 답을 맞춘 후에 봤는데, Up 상태에서 답에 도달할 경우에는 항상 down을 하지 않는다.
이게 up-down으로 몫을 구해놓으면, 이게 down까지 이뤄졌을 경우에 값이 곧 몫이 되는 건데,

답은 일단 식으로 설명하면 (V-B)/(A-B) 이다.
왜 V-B일까? 여기서 A-B는 다들 알다시피 한 사이클이 도는 시간이다.
여기서 V/(A-B)를 하게 되면, 이것은 B까지 한 사이클을 다 돌았다는 의미가 된다.
즉, 3 1 9를 예로 들면 이는 먼저 9에 도달해서 4일차에 끝났어야 하는데, Down을 강제로 해서 8로 만들어놓은 경우인 것이다.
실제 값에 도달하게 되면, Down은 진행되지 않으므로, Up보다 Down은 항상 한 값이 작다.
그래서, answer = N, up = A, down= B라고 하면, N*A - (N-1)*B = V라고 하면
NA - NB + N = V
N(A-B) + B = V
N = (V-B)/(A-B) 가 되는 것이다.
이렇게 했을 때, 나머지가 남는 경우가 있고 남지 않는 경우가 있는데,
남지 않는 경우는 그냥 값이 결국 N인거고,
남는 경우라면, 아직 V에 도달하지 못한 경우이므로(답으로부터 하루 전),
하루만 더 Up을 하면 V에 도달할 수 있기 때문에, N+1을 해준다.

이렇게 풀었다. 정확하게는 뒷걸음치다가 우연찮게 하긴 했지만, 뭐... 맞아서 다행이다.

