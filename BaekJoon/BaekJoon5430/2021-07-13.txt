1966번 프린터 큐

Queue를 활용하는건데, 자신 뒤에 중요도가 높은게 단 하나라도 있다면, Queue의 맨 뒤로 재배치하는 방법이다.
Queue에 들어가는 개수가 매우 작아서 O(N^2)으로 해도 큰 문제는 없을 것 같기 때문에 일단 이렇게 해본다.
기능은 문제 없는데 메모리 초과가 난다.
어디서 줄일 수 있을까... Queue를 계속 참조하기 때문에 문제가 생기는 걸까...?

정답은 Queue에 불필요한 요소들이 자꾸 들어갈 수 있기 때문.
자기보다 큰 값이 1번이라도 나오면 그냥 Queue에 해당 값을 다시 넣어주고 그대로 종료하면 되는데
꼭, 10까지 계속 돌면서 큰 값이 나올때마다 Queue에 추가를 하게 되니깐 메모리가 초과한 것 같다.

--------------------------------------------------------------------------------------------------------------------------

5430번 AC

Deque를 통해서 풀면 되는 문제고, 문제 자체는 매우 간단하나 출력 형식에 있어서 큰 문제가 있다.
일단 Arrays.toString() 으로는 형태가 맞지 않아서 틀리고, 그럼 하나하나 형태를 다 만들어줘야하는데
일반적인 for문으로 하니깐 또 시간초과 떠버리고, list 값도 제대로 참조가 되지 않아서
향상된 for문에 count 하나를 추가해서 그냥 출력 형식을 맞춰서 출력시켜줬다.
정답은 맞는데 그냥 빡이 친다.

Deque로는 어떻게 풀었냐면, bool 변수를 하나 두고, false면 pollFirst, true면 pollLast로 되도록 설계한 뒤
D가 나오면 bool 변수에 따라서 저 형태를 실행한다.
R은 단순히 bool 변수를 바꿔주는데 있고, 만약 deque가 비었으면 비었다고 알려주는 bool 변수를 하나 더 선언한 후 이를 알려준다.
작업이 끝나게 되면 아까 선언한 bool 변수에 따라서 error 또는 배열 형태의 출력을 출력해주면 끝.
