9663 N-Queens 문제

Queen이 서로 공격할 수 없는 위치에 있을 수 있는 경우의 수를 구하는 문제.

전형적인 백트래킹의 대표 문제이며, 반드시 이해해야하는 문제.
체스의 Queen은 자신의 가로, 세로, 대각선에 해당하는 칸을 이동해서 공격할 수 있다.
즉, 한 Queen을 놓게 되면 제한되는 구역이 생기게 된다.
이 제한되는 구역을 계속 알아내가야하는 방식이므로 재귀 형태의 방법을 사용하게 되고,
저장되어 있는 Queen의 위치와 놓을 곳을 비교하고, 조건에 맞으면 그 곳을 기록하고
다시 n번째 Queen의 위치를 반복적으로 찾아나가는 과정이다.

여기서 Back-tracking 기법이 사용되는 이유는, 불필요한 계산을 하지 말자는 이유이다.
한마디로, 안되는 경우의 수를 끝까지 가져가지 말자는 이유이다.
그래서 만약 n번째 Queen까지 가는 과정에서 만약 공격이 가능해지면, 깔끔하게 다음 경우의 수를
판단하지 않는 방법이다. 즉, 다음 경우의 수에서 다시 Back 한 후 다시 Tracking 한다고 생각하면 된다.

그래서 풀이 방법은, 한 블로그를 참고하여 작성하였고, 이는 이렇게 풀이된다.
1. 1차원 배열로 index를 열, element를 행으로 삼아 2차원 N*N 형태를 만들어낸다.
2. 각 열을 기준으로 놓여있는 Queen을 첫 번째 Queen의 위치로 삼았을 때 가능한 2번째 열의 경우의 수를 구한다.
2-1. 이 과정에서 행을 기준으로 바라봤을 때, 만약 Queen이 있다면 back-tracking.
2-2. 이 과정에서 대각선을 기준으로 바라봤을 때, Queen이 있다면 back-tracking.
2-3. 열을 하지 않는 이유는 알듯이 한 열에 1개만 들어가있기 때문에 체크하지 않아도 무방.
3. 1,2번째 Queen을 기준으로 3번째, 1,2,3번쨰 Queen을 기준으로 4번째 Queen이 놓아질 수 있는 경우를 찾는 방식으로
N개까지 이어간다.
4. 만약 그 과정에서 모든 Queen이 들어가게 된다면, count++ 후 return.


----------------------------------------------------------------------------------------------

1978번 소수 찾기

이거 에라토스테네스의 체를 사용하고, 1000까지의 소수만 판별해놓으면 되긴 하는데
자바는 BigInteger 라이브러리의 isProbablePrime(10)을 사용하면 어지간한 소수는 다 판단이 가능하고,
범위가 적으므로 이정도로 해도 크게 문제가 없을 것 같아서 이렇게 구현했음.

정석은 에라토스테네스의 체를 사용해야한다. 이것만 기억하고 알고리즘을 기억해두면 됨.
