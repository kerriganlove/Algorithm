4673번 셀프 넘버

구현문제로써, 나는 이 문제를 다른 알고리즘 방식으로도 풀 수 있을까 생각해보았지만
그러한 방법은 없었다.
어차피 생성자가 단 1개라도 있으면, 중복으로 넣지 않아도 되므로
반복문은 10000번 돌아가게 되는것이다. 이 작업이 1초를 넘지는 않을 것이므로
구현에 가깝고, 구현 방법은 원래수+자리수들 로 구성하게끔 만들면 된다.

간단한 구현 작업이지만, 아이디어가 매우 중요한 문제이다.

-------------------------------------------------------------------------------------------


2504번, 괄호의 값

Stack 구현이다.
처음에는 여러개의 스택을 사용해서, 각 값을 전부 구한 뒤, 더할 때는 더하고, 곱할때는 곱하려고 했으나
이게, 최대한 s에 대한 참조를 없애면서 하려고 하니 절대 안됬다.
정확하게는, 여러개를 더해야 하는 상황을 해결해내지 못했다.(2개까지는 어떻게 해결 함)
여러개를 더하고 곱해야 하는 상황을 절대 만들어내지 못해서

다른 사람들의 질문글에 있는 아이디어를 살펴본 결과, ( or [ 에 대해서 각 2와 3을 계속 곱해주고
만약 )나 ]이 나온다면, 그 숫자에서부터 answer을 시작해서 가감하는 방식을 넣었다.
예를 들자면
(([]())) 이라고 하면
(([ 에 의해서 temp = 12가 된다. 그 상황에서 ] 차례시 바로 앞에 [가 있으므로, result = 12, temp = 4 가 된다.
그 뒤 다시 temp = 8이 되고 (( ( , result는 ) 일 때 다시 바로 앞에 (가 있으므로, result = 20, temp = 4 가 된다.
그 뒤 ) 이 나오고 자신 바로 앞에는 ( 이 없으므로 temp만 줄어나가게 된다.

더하기의 개념을 잘 이해하지는 못하겠지만, 아마 분배법칙에 의거해서
(([])) + ((())) 을 넣어둔 것이라고 생각해봤다.
이런식으로 분배법칙을 통해서 문제를 풀게 되면, (([](([])))) 의 경우
(([])) + (((([])))) 이 되게 되는 방식이다. 즉, 1개짜리가 숫자가 되고, 그 앞까지는 전부 곱해지는 수가 되는 것이다.
여기서 만약, stack에 더 이상 쌓여있지 않거나(괄호의 개수가 맞지 않을 경우) 혹은 앞에 빼낸 것이 (이 아닌 경우에는 판단 변수를 통해서
모두 상황을 걸러주었다.

여기서 느낀 점은 아직 아이디어를 펼치기에는 너무나도 부족한 수준이고, 이런 아이디어를 찾을 때, 특히 구현 문제에서는
수학적인 공식을 이용하면 좋은 것들이 많다는 점을 배웠다.
그러나, 이렇게 이런 식의 지식을 안다고 해도 막상 가서 풀 수 있을 정도가 되려면 백준에 있는 문제 정도는 다 풀 수 있어야 하지 않을까.
(2~3시간 이내로)
 