5054번 주차의 신

너무 쉬운 문제. 끝. 그냥 설명이 필요없음.
두 지역을 전부 둘러볼 수 있는 최소한의 거리는 일직선으로 쭉 갔다가
일직선으로 쭉 나오는것이 최소 거리. 따라서 0에서 제일 가까운 지점에서 출발하여
가장 먼 지점으로 도착하는 것이 깔끔함. 그래서 Sort하고 그냥 맨 처음과 맨 끝 거리해서
왕복이므로 *2만 해주면 끝.

10025번 게으른 백곰

가장 적은 거리로 가장 많은 얼음을 차지해야하는 문제

거리와 관련된거면 보통 DFS,BFS이긴 한데 좌표가 있다고는 하나 1차원 배열에서의 DFS,BFS는 못들어봄.
DP는 점화식을 세울 수 있나 보니깐 앞 숫자와 뒷 숫자간의 연관성이 없음.
이분 탐색 쪽으로 풀어볼까...?

일단 도저히 모르겠어서 보니까 두 포인터였다. 기존의 탐색 과정에 대해서 시간이 줄어드는 개념이기 때문에
일단 저번에 했던 두 포인터 문제를 한 번 살펴본 후 진행해야겠다.

두 포인터 = 부분합이라는 공식을 세워둔터라서 만약 이렇게 되면 이런 식으로 하는 것이 옳다.
두 포인터는 근데 그 부분에 대한 범위인데, 양 끝값을 기준으로 삼아야 하는 건지에 대해서 생각이 든다.

만약 그렇게 한다면 투 포인터라는 느낌보다는 위치를 옮겨주는 값이라고 생각하면 편할 것 같다.
그렇다면 슬라이딩 윈도우는 어떨까? 오히려 이 문제와 더 잘맞는 것 같다.
특정 길이는 이미 정해지기 때문에(좌,우로 3, 즉 길이로만 따지면 중심값을 포함해 7의 길이를 가지게 된다.)
0에서부터라면 0,1,2,3,4,5,6까지의 범위이고
1에서부터라면 1~7까지의 범위일 것이기 때문에
이를 응용하면 매우 쉬워질 것으로 예상.

슬라이딩 윈도우 알고리즘의 기초 of 기초의 문제로 길이만 잘 설정해주면 아주 쉽게 풀 수 있는 문제이다.
범위가 x값을 넘어가기도 해서 어? 이런다면 그건 걱정 안해도 됨. 그냥 뻗는 손의 위치가 다 닿는다고 생각하면
전체의 합을 구하는 문제와 다른 것이 없음.

