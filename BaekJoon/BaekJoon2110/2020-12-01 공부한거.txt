1. 보는 방향으로 ++

2. 만약 사과 없으면(0) -> 뱀의 길이는 1, 머리 위치도 그와 동일(즉, 그 칸만 x)

3. 사과가 있으면 -> 뱀의 길이++, 머리 위치는 현재와 동일(몸의 현재 상태를 나타낼
공간 필요)


BFS로 구현하고

각 위치마다

현재 뱀의 몸 상태 = 2

사과 = 1

지나가지 않은 곳 = 0

몸이 줄어들면 그 공간은 지나갈 수 있으므로 0
(사과를 만나면 캐싱해둔 전 값들의 값을 0으로 전부 치환)
-> 위치를 저장할 수 있는 2차원 배열 1개 선언

sec = 0;
sec++;
맨 처음은 x < 0, x > N, y < 0, y >N 일때 게임 종료

if ( list[][] == 0 ) { list[][] = 2, 전 값들 대입 = 0 }
else if ( list[][] == 1 ) { list[][] =2, length++, 이 값 저장 } -> 
q에 있는 값들 꺼내서 (지나왔던 길이니까 이게)
else if ( list[][] == 2 ) { 게임 종료 }

방향에 따른 switch case문 지정
현 방향은 sec++ 이후 결정.


결론 : 조건문도 다시 한 번 보고 수정해봐라.
겨우 0보다 큰지 작은지에 대한 그 판단 하나로
완전히 다 달라짐.

그리고 아이디어를 따져봤을때


---------------------------------------------------------------------

위의 아이디어에서 풀이까지 종합해봤을 때

1. BFS로 해결하는 방법은 완벽한 풀이. 길 찾기(도착점까지의 시간 구하기 등) 은
Default = BFS로 해놓고 풀어야 한다.

2. 또한 Queue를 사용하는데 있어서 위의 풀이는 그 Q에 전 값들을 저장한다고 했는데
이는 몸 길이를 계속 1로 만들어야하는 줄 알았던 내 패착이었지만.
오히려 이 아이디어가 몸길이를 유지하면서 현재 뱀의 위치를 판단해낼 수 있었던 것.

3. 그래서 어떻게 풀었냐

map 상에서 사과가 없다면
Queue를 2개 사용한다. 둘 다 선입선출이 필요하므로
1개의 큐는 다음 위치 선정
1개의 큐는 몸길이에 따른 현재 뱀의 몸이 있는 위치
0이라면 길이는 유지하고, 몸은 그 방향으로 나아가기 위해서
맨 뒤에 있는 꼬리를 앞으로 옮겨야 한다.
그것을 위해 선입선출인 Queue의 구조를 사용하여
제일 먼저 들어간 값을 빼내어 그 부분을 0으로 만들어준다.(사과는 없으므로)
그 뒤 판단하고자 하는 위치를 2로 만들어주고, 이를 2개의 큐에 정보로 저장해주낟.

map 상에 사과가 있다면
길이와 머리 모두가 늘어나게 된다.
이 때는 다른건 없고, 양 Queue에 현재 위치의 값을 저장해주면 된다.

그리고 이 과정이 끝난 직후에 현재 시간에 대해 HashMap을 사용하여
key값인 초를 대입해 있다면 조건에 따라 방향을 바꿔주면 되는 것이다.
이를 반복하면 정답.

--------------------------------------------------------------------------------------------------------

일단 DFS를 통해서 그 공간에 L이 2개가 된다면(중간 판단) 현재 Day를 방출

만약 안된다면, Map을 변경 후 다시 DFS 실행

Map 변경 과정을 코딩해야되는데

인접해있는 모든 X를 .으로 바꿔야한다.

DFS의 원리는 저 4개를 다 통과하면 그것은 공간이 있다고 보는거고
돌아오는 boolean의 횟수에 따라 갯수가 정해지는 느낌이다.

저 공간 안에 L이나 .이 있다면, 그것을 X로 바꾼 뒤에 L의 경우는 그 공간에서의 Count를 하는거지
그래서 그 count가 2라면 return true;
아니면 return false;

-> 포기, 다 BFS 써야된다고 하는데, 나는 모르겠음. 왜 BFS인지
Map의 공간에 L이 포함되는 것을 보려면 아이스크림 문제 같이 DFS를 써야하는거 같은데
왜 BFS를 쓰는지도 모르겠고, L 판단 기준도 좀 더 고민해볼 필요가 있음.

----------------------------------------------------------------------------------------------------------

3111번 검열

KMP 알고리즘을 통해서 1번 판단.
검열한 후 문자열 자르고
문자열을 뒤집어 판단
검열한 후
문자열을 뒤집어 1번으로 되돌아감.

나는 1번만 찾으면 되고
기존 코드는 끝까지 돌아가는 코드인거임
그럼
1번만 찾으면 되니까
j가 org의 위치

bacccababa
니까
bacccab가 남으면 됨.
다 뒤집고 남은 결과가
시간 초과 떴네 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
아마 KMP는 단순 개수 검색 알고리즘 비슷한거라
이를 몇번 돌리느냐에 따라서 시간 복잡도가 결정되는듯?

그럼 여기에 적힌
문자열과 스택 개념으로 봅시다.

1. Stack은 first in last out
둘 다 포기

------------------------------------------------------------------------------------

2110

이분 탐색이었다고 한다.
이분 탐색을 보는 순간 거리의 최대값과 최소값을 생각해냈지만
그게 다였고, 최대값과 최소값의 mid 기준을 어떻게 삼아야 하는지를 생각하지 못함.
그래서 문제의 조건을 좀 더 잘 찾아봐야한다고 생각한다.
이번 같은 경우는 공유기의 숫자가 쓰일일이 없었는데
이런 문제에서 쓸 수 있다는 생각을 했어야 한다.
즉, 앞에서부터 mid로 나온 거리까지를 계산하여
앞에서부터 바로 앞 지점까지의 값을 계산하여 mid 값과 비교해
만약 이 거리가 mid값과 같거나 작다면 그 거리를 허용할 수 있는 수준이므로
count를 올린다.
그 count는 결국 공유기의 숫자이고
공유기의 숫자가 실제 설치하고자 하는 숫자보다 작으면 더 설치해야하므로 거리를 좁혀야하고
공유기의 숫자가 설치 숫자보다 크거나 같다면 그 거리를 답으로 삼고, 최대한 그 숫자를 작게 하는 방식으로 거리를 넓혀야한다.