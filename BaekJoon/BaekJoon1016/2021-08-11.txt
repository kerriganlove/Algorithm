15711번 환상의 짝꿍

처음에는 모든 경우의 수를 다 구해보려고
에라토스테네스의 체를 활용하여 판별해내려고 했다.
그러나, 시간 초과가 났고 수의 특성에 대해서 생각해보았다.
그리고, 두 값의 합이 홀수와 짝수로 나뉠 때를 생각해보고
순간 골드바흐의 추측이 생각이 났다.
즉, 짝수는 소수 2개의 합으로 전부 나타낼 수 있다는 것이었다.
물론, 여기서 더 찾아보니 4 이상이어야 하고, 일단 400조까지는 추측이 맞았다고 증명이 됬기 때문에
이를 활용하여, 만약 두 값의 합이 짝수고, 2 이상이라면 골드바흐의 추측에 따라 소수 2개로 나눌 수 있다고 봤다.

여기서 수를 홀수로 뒀을때, 수는 홀수 + 짝수의 개념으로 나눌 수 있다. 여기서 짝수는 2를 제외하고는 소수가 없다는 것이
이미 증명이 되었고, 그래서, 홀수 + 2일 때만 소수를 판별하면 된다고 생각했다.
그래서 이 홀수에 대해서만 소수 판별을 진행했는데, 이게 또 숫자가 커서 에라스토테네스의 체를 활용하면
시간 초과가 났다. 그래서 Java 라이브러리인 isProbablePrime을 활용하여 계산을 완료하니까 정답이 나왔다.
아마, 이게 에라스토테네스의 체를 통해서 판별하지 못하는 범위 안에 있는 소수까지 빠르게 판별할 수 있는 다른 방법으로 
설계가 된 것 같다.

----------------------------------------------------------------------------------------------------------------------------------

1016번 제곱 ㄴㄴ 수

구현은 완료했다.
단순하게 하나하나 비교하는 방향으로 일단 비교를 했는데, 시간 초과가 떴다.
이걸 줄여가야하는 방향으로 설계를 해야하는데...
결국 list의 크기만큼은 돌아야한다. 그래야 숫자를 전부 돌 수 있으니까.
그리고 제곱근을 만들어주기 위해서는 2부터의 제곱근 값 또한 만들어주어야한다.
이는 최대 1,000,000이기 때문에 원래는 이렇게 되면 당연히
이중 for문에서 O(N^2)이 나올 수 밖에 없다.
NlogN 정도만 나오게 할 수 있다면 좋을텐데.
그럼 안에 있는 게 logN이 나와야 할까?

만약 이게 범위가 작았더라면, list index에 직접적인 값을 대입함으로써 소수의 에라스토테네스의 체와 같은 방향성으로
구현을 했을 것 같다. 그러나, 최대 1조인 숫자를 메모리에 할당하는건 애초에 안된다.
이게 제곱수의 배수를 찾는 과정이긴 한데, 그렇다고...

일단 구하긴 했고, 기본적으로 에라스토테네스의 체를 응용하는 방향이 맞았다.
단, 내가 구한 방법은 가장 standard한 방법으로 구할 수 있는 방법이었고, 이는 O(N^2)이기 때문에 맞지 않는다.
그래서 다른 사람들이 구한 방식은, 제곱근별로 min~max까지의 몫을 구한 뒤 몫을 올려가며 max값까지의 판별을 하는 것이다.
이렇게 되면 모든 값을 다 돌며 제곱ㄴㄴ수를 구하는게 아닌, 제곱수에 나눠지는 값을 구하는 거라서
모든 list들을 전부 돌지 않아도 되기 때문에 시간이 대폭 줄어들게 된다.

좀 더 디테일함이 필요했고, 생각을 많이 해봤어야 하는 문제였다고 생각한다. 이런 문제들이 코딩 테스트에 나오는 것들이다.
단순한 문제지만, 시간복잡도의 설계를 디테일하게 하는 이런 문제. 이거보다 좀 더 파악하기 쉬운 문제들이라도
데이터를 제대로 해석할 수 있어야만 테스트를 합격할 수 있을 것이다.


