15686번 치킨 배달

치킨집을 없애면 -> 치킨 거리가 달라진다 -> 도시의 치킨거리도 달라진다.

1. 치킨집을 없애는 과정은 어떻게 할 것인가...?
2가지 방법을 보았다. 하나는 조합을 활용해서 집의 경우의 수를 모두 구한 다음,
경우의 수만큼 치킨 거리를 구해서 Min값을 구하는 방법.
가장 이해가 쉽고, 개인적으로는 단순하게 생각하기에 좋은 Brutal-force 기법.

나머지 하나는 DFS를 이용하는 방법인데, visited를 활용하여 M개까지의 치킨 집을 정하고,
M개가 되면, 치킨 거리를 구해서, 기존에 저장해둔 도시의 치킨거리와 비교해서
정답을 내놓는 방식이다.
좀 더 기술적인 부분을 활용하는 알고리즘이라고 생각한다.

여기서 배워야할 점은 개수가 많지 않고, 우회할 수 있는 방법이 생각나지 않으면
브루탈-포스 방식을 항상 떠올려야한다. 그리고 그렇게 하기 위한 DFS, Back-tracking 과정과 같이
사용되는 방법 또한 조기에 눈치챌 수 있어야 한다. 특히, 이런 반복적인 작업의 경우는 DFS 같은 방식이
가장 많이 선호되는 방식이고, 주로 이렇게 풀리기 때문에 이것은 항상 기억해두어야 한다.


----------------------------------------------------------------------------------------------------------

2661번 좋은 수열

부분 수열이 중복되지 않는 수열을 좋은 수열이라고 하는데, 이 좋은 수열의 최솟값을 찾아라.

back-tracking을 활용하여 재귀함수 느낌으로 풀고 싶음.
그런데 N의 길이가 80까지 있다는 건 다 구해서 최솟값을 찾을 수 있는 과정은 아니라는 얘기
즉, 만들면서 최솟값이 되게 만들어야 한다.

어떻게 만들어야 할까...?
일단 한 숫자가 정해지면 다음 숫자는 그 숫자가 나와서는 안된다.
일단 Back-tracking은 맞음. 맞지 않으면 돌아가야함. 수열이 맞지 않았던 부분으로.

결과적으론 Back-tracking은 맞지만, 이를 구현하는 방법을 제대로 익히지 못한 것 같다.
그래서 DFS, Back-tracking은 반드시 익혀두고 가야할 것 같다...

마지막 메모리 초과의 경우는 길이가 N인 것을 계속 찾아가기 때문에 메모리를 더 쓰게 된다.
그래서 아예 맨 처음으로 나오는 답이 결국은 최솟값이므로, 그게 구해졌다면 다음부터는
boolean 함수를 써서 모든 작업을 멈추도록 한다.


