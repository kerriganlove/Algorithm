11053번 가장 긴 증가하는 부분 수열

맨 처음에는 그냥 부분집합의 형태로 그려져있어서
그런가보다하고, 치웠는데...
부분 수열의 의미가 1~N까지 순서대로 올라가야한다는 것으로
가정을 하면, 내가 설립한 이론은 틀렸다.

그래서 DP[N]의 값을 N의 위치에서 가장 긴 부분 수열의 길이로 하고 점화식을 짜봄.
이 때, 주의해야할 점이 있다면, 계산을 시작하기 전, 모든 값은 자기 자신 또한 부분 수열이므로,
길이를 무조건 1로 잡고 시작해야한다.
그렇게 되지 않으면, 초기화하지 않는 상태에서 진행해오던 수열이 끊기게 된다고 했을 때,
그 시작점의 카운트 하나가 없어지게 된다. 왜냐하면, 자기 자신 또한 수열의 길이로 포함시켜야하는데
값이 0이라, 그게 안된다는 것이다.

그래서 그렇게 만든 후, 이중 for문을 돌면서, arr에 있는 자신의 값이 앞 값들보다 클때만
가장 긴 길이를 찾아내서 자신의 값에 저장해두면 끝이다.
그 뒤, 그렇게 쌓여있는 dp 배열의 값들은 자신의 위치에서 가장 긴 수열의 길이이기 때문에
여기서 최댓값을 다시 찾아줘야, 가장 긴 부분 수열의 길이가 되는 것이다.

문제의 조건을 처음에는 제대로 해석 못했지만, 그 뒤에는 가볍게 풀었다.
쉬운 문제였고, 실버 수준이었기 때문에, 당연히 풀었어야 한다고 생각한다.
DP 문제라고 해석할 수 있는 능력과(메모리가 크고, 시간이 안 맞을 경우 정도?)
점화식을 세우는 능력. 딱 이 2가지만 갖추면 어느정도 선까지는 다 맞출 수 있지 않을까? 하는 생각이 든다.


--------------------------------------------------------------------------------------------------------


11047번 동전 0

동전을 적절히 사용해서 해당 가치를 가장 적은 동전의 갯수로 만들 수 있게끔 해라.
최솟값 문제, 그리디 같다. 막말로 최솟값이면, 제일 큰걸 때려박아넣고, 남는 공간에 들어갈 수 있는 만큼
제일 큰 가치를 계속 넣으면 가장 적어지지 않을까?

저번에도 백팩문제인 줄 알고 최댓값을 이런 식으로 달려들었다가, 아니긴 했어서 조금 당황했는데
이번에는 별 다른 조건이 없어서 괜찮은 거 같음.

정답이었고, 그냥 간단하게 조건만 해석해서 풀었던 문제라서 딱히 어려운 건 없었따.
다만 오름차순이니깐 배열을 뒤집어서 생각하고, 계산이 끝나면 반복문을 끊어야한다는 점정도?
좀 더 깔끔하게 풀 수도 있지 않을까? 이런 생각이 들긴 하지만, 답은 냈으니까 좋다.