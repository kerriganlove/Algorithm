1932번 정수 삼각형

완전 이진 트리에 누적합을 만드는 과정이라고 생각하면
맨 마지막 자식들만 Max 시키면 되는 것.

그런데 트리를 만들게 되면 
2^n - 1이 되는데
그럼 2^500-1이고, 이러면 메모리에 들어가지도 않을 것 같음. 그럼 이건 완전 파기.

그럼 DP도 마찬가지고, 2^500-1 만큼의 메모리가 필요한 것.
// 여기까지가 답을 모르던 상태에서 생각한 것.
                                         
DP든, 다른 문제든 경우의 수에 대한 경로 혹은 개수를 구하는게 아니고
단순히 값을 원한다면, 그걸 원하는대로만 구현해주면 된다.
최댓값이면 최댓값을 구할 수 있는 경로로 유도하고, 최솟값이면 최솟값을 구할 수 있는 경로로 유인하면 된다.

다른 사람들은 재귀함수를 호출하는 형식으로 많이 구현을 하였지만
실제 DP는 최댓값을 구하는 방식이므로, 그냥 역으로 추적한다고 생각한다면 오히려 쉽다.

-----------------------------------------------------------------------------------------

1149번 RGB거리

얘도 느낌이 비슷한 DP일 것으로 예상된다.

내 생각에는 DP[N+1][N+1] arr[N+1][N+1]을 구해두고
DP[1] = arr[1]로 삼은 후 DP[2][] = Math.min(DP[1][] + arr[2]어나더 2개)
그런데 이렇게 하면 안되는게 하나 있음.
이것도 어찌보면 제약조건이 있는 경로를 찾는거라고 보면 되는데
이렇게 되면 그 제약조건이 맞지 않는 경로로 들어갈 수도 있음.
그럼 이를 억제할 수 있는 1차적인 방어선이 필요할 거 같다.

그래서 제약으로 생각한게 Stack 개념을 도입해서 가지 말야야 할 숫자를
저장해두는게 가장 1차원적인 생각인데
내가 생각했을때는 DP차원 안에서 해결할 수도 있을 것 같다.

최솟값의 경로는 1개다.

만약 앞의 형태로 무언가를 하려고 하면, 그 값을 도는 또 하나의 for문이 있어야 한다.
그렇다면 아니라고 보고, 다른 방법을 생각해보면 될 거 같다.

라고 생각했는데 그냥 내가 멍청하게 문제를 잘못 해석했다.

RGB이기 때문에 색깔은 3개밖에 없기 때문에
DP나 arr은 DP[N][1],[2],[3]일 수 밖에 없다.
그에 따라 DP[N+1][1] = min(DP[N][2], DP[N][3]) + arr[N+1][1];
이 될 수 밖에 없다. 
아주 단순한 문제였고, 전 문제를 풀었던 입장에서 최솟값에 초점을 맞추고 풀이법을 잘 해석했다고 생각한다.
왜 이렇게 되냐면, 결국 제약조건들이 전부 지켜지려면, N+1의 입장에서는 N이 무엇을 선택했는지만 알면 된다고 보면 된다.
그럼 N+2는 어떤 색깔이 되도 제약조건이 걸리지 않기 때문에, N+1의 입장에서 N이 자신의 색깔과 같지만 않으면 되는 것이다.



