1939 중량제한

양방향의 길이 있고, 그 길을 지나갈 수 있는 중량은 제한되어있다.
이 때, 중량의 최댓값을 구하라.

양방향 문제고, 거리 비슷한게 있어서 다익스트라로 접근했다.
다만, 기존의 최단거리를 구하는 방식과는 다르게 식을 짰다.

먼저, 원래 list[start] = 0이어야하지만, 실제는 1~1로 나를 수 있는 무게는 무한하므로
가장 큰 수를 집어넣는다(내 기준 987654321)

그 뒤, 만약 계산된 최대 중량이 현재 점의 위치의 cost보다 작을 경우
점 위치의 cost와 갈 수 있는 위치의 cost간의 최솟점을 구한다.
즉, 내가 1-2로 4를 옮겨왔어도, 2-3이 2밖에 옮기지 못한다면 2만 옮길 수 있기 때문이다.
그 뒤, 그 점과 비교시 내가 옮길 수 있는 최대중량이 더 크면
옮기는 것으로 마무리한다.

아이디어는 다 떠올렸는데 문제의 근본을 좀 더 이해하고 풀었으면 매우 쉬웠을 문제이다.

그런데, 시간 초과가 났다.
아무래도 n,m의 크기가 너무 커서, 시간초과가 나는 것 같아서 다른 방법을 물색해본 결과
BFS+binary search 방법으로 풀게 되었다.

이 부분은 잘 모르겠는데 일단 말로 풀면

이분탐색하는 부분은 0~10억, 즉, 중량으로 계산하고,
BFS는 start,end를 이용해서, start부터 end로 도달할 때까지를 계산하면 되는 것이고,
만약 BFS가 도달하지 못하면 left를 아니면 right를 각각 mid+1, mid-1로 값을 바꾸어
계속 이분탐색을 하면, 결국 최대 중량이 나오게 된다.
끝. 원리는 모르겠음.

------------------------------------------------------------------------------------------


2585번 경비행기

비슷한 문제 같은데, 연료통에 제한이 있고, 내릴 수 있는 횟수 또한 제한이 된다.
음... 일단, 최소 연료통이기 때문에, 모든 경우의 수를 다 구하는게 맞는지를 잘 모르겠다
일단 시작점과 도착점이 정해져있기 때문에, 1번 내린다고 가정하면,
한번 내렸을때의 값들을 적어두고, 그 위치에서 다음 위치까지의 값을 계산해야되고...

이분탐색 + BFS 문제인데, 좀 더 이해가 필요해 보인다.
이분탐색은 연료통의 값을 줄여가면서 탐색한다는 것이고,
만약 값이 걸려서 그 연료통의 크기를 통해서 도착하면 end 값을 mid-1로
만약 도착하지 못하면 start 값을 mid+1로 바꾸면 될 것 같다.
문제는 BFS인데, 시작, 도착점이 정해져있으므로, 시작점에서부터 주어진 좌표들을 돌면서
시작점과 거리를 비교하고, 통과하면 끝점과의 거리를 비교해서 둘 다 갈 수 있는 연료통의 크기인지를 비교한다.
그 뒤, cnt를 ++하면서 k값을 넘어서면 종료하고, 갈 수 있다는 판정을 내리게 된다.

솔직히 BFS 부분이 제대로 이해가 가지 않는 것이 사실이다.
