와... 애들 아이디어가 진짜 대박이긴 하다.
1654번 생각 루트
처음에는 그리디인줄 알았음.
왜나하면 가장 짧은 길이를 기준으로 잘라내면 될것이라고 생각했기 때문임.
근데 이런 생각 자체가 그리디 알고리즘과는 맞지 않음.
그리디는 가장 좋은 경우고, 뭔가 딱딱 맞아 떨어져야지만 가능한 부분.
그래서 도저히 그리디 알고리즘으로 뽑아낼수 없다고 판단하고, 분류를 봣는데
이분 탐색임
??

솔직히 놀램
이분 탐색을 어떻게 하지?
그래서 생각을 조금 해보니 정렬된 데이터에서 K 길이 만큼의 데이터를 그다지 반복적으로 읽지 않아도
길이의 폭을 줄일 수 있다는 생각을 함.
길이에서 그 힌트를 찾을 수 있음. 2^31 - 1 이면 길이상으로 길고, 이 길이에 대해서
for문을 돌려서 개수를 일일히 찾아내면 무조건 런타임 오류가 뜰 거니까

그래서 이 길이의 폭을 줄일 생각을 해봐야 한다.
그래서 맨 처음에는 최소 길이만큼의 바이너리 서치를 하면 되나 생각했음.
근데 처음에는 그냥 N,K가 같을 때 자를수가 없는 조건이 나와서 그런줄 알았는데
그건 그냥 아니고, 단순히 생각해서, 가장 짧은게 1이고, 가장 긴게 1000이라고 치자
그럼, 얘를 N = 11정도라고 하면
가장 짧은 기준으로 하면 ans = 1000 + a 가 나오겠지만, 이건 원하는 답이 아님
왜냐하면 2로 해도 ans = 500이라 조건을 충족하고
오히려 답이 2가 되어야하는 상황이거든요. 그러니까 비교 자체가 불가능한겁니다.
그래서 제일 긴 길이를 기준으로 해야됩니다.
짧은 길이의 랜선이 버려질수 있다는 생각을 해야합니다.

결론 = 이분탐색 구현 자체는 쉬웠고, 이런 계산을 할 수 있는 경지까지는 가야합니다.

그렇게 풀면 안됩니다 일단
그냥 그렇게 배열을 일일히 다 탐색하면 안되구요
그렇다고 이걸 정렬할수는 없습니다. 그래서 이분 탐색도 안됩니다.

DP로 풀기에는 그냥 아닙니다.
단순히 문자열 검색인데, KMP로 구하는 것도 이상합니다.
지금 for (N+M) 이잖아요
숫자를 말하면 그냥 for(숫자 문제 개수) 인거라서 노상관입니다.
-> 답은, 자료 구조였다.

자료 구조 상에서 나는 검색이 가장 빠른 ArrayList를 1차로 사용했다.
그런데 시간초과가 났다.
왜 났을까
답은 그거였다. ArrayList가 아무리 빨라도, 숫자와 문자 구분을 위한 연산을 해야한다.
그러한 연산을 O(M)을 해야하므로, 그 안의 연산 결과에 따라서 시간이 결정되는 것이다.
그래서, Hash 혹은 TreeMap 자료 구조로 접근하라는 소리를 보고
Map은 검색이 더 느린데 어떻게 하라는거지? 이런 생각이 들었다.
그러나 예시를 보자마자 바로 알아버렸다.
key와 value를 적는것이 Map 자료구조의 특징인데, 여기서 key가 포켓몬 이름과 숫자가 되면
그냥 집어내는대로 찾아만 내면 되는 것이다. 중복이 되던 말던, 등록이 된 순서와 이름을 입력해두면 되는것이다.
그리고 이름과 순서의 방향을 바꿔, Map에 다시 한 번 저장해두는 것이다.
어차피 10만개이기 때문에 최대 20만개이고, 메모리를 침범하지 않는 것이다.

그리고 Key 값에 그것을 던져주게 되면 연산 자체가 줄어드므로
ArrayList에서 탐색 연산 속도가 아무리 작아도, 중간의 자체 연산 시간이 더욱 많이 걸려
Map의 탐색 연산 속도를 못잡는 것이다.

그래서 느꼈다.
혹시나 서로 Switch된 자료를 찾아야 된다면 ( 예를 들어, 쌍을 이뤄야 되는 자료들에 대해서 )
Map을 쓰는 것을 고려해봐야한다는 것을.

