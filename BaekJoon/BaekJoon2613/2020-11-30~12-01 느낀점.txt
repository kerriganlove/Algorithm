다시 시작합니다.

일단 제 아이디어 중 가장 맞는거 같은건
dp[i] 값이 결국 1~i번째까지의 구슬 값이라는 것
즉 이 말은
dp[end] - dp[start] = start+1 ~ end까지의 값
즉,
1~4
1~7을 빼면 567이 남는 것
이런 식으로 구간의 합을 구할 수도 있음.
-> 이까지는 맞는 생각이라고 합니다.

* 여기서부터는 검색을 통해 알아낸 풀이법
1. 최대값의 최소값을 알아내기 위해서는 이진 탐색을 활용해야 한다.
시작 값은 1, 끝값은 최대로 나올 수 있는 값 ( 나라면, dp[N] 값이라고 생각 )
그래서 middle 값을 본다. 그럼 얼마정도의 값이 나오겠죠?

그럼 그 값이 포함되는 구간을 찾아봅니다. 그래서 구간이 현재 우리가 자른 M보다
많거나 같게 되면, 일단, 제대로 최대값을 찾고 있다는 의미입니다.(최대값의 최소값을)
네, 그렇게 되서

최대값보다 큰 값들이 있으면 그 최대값에 대한 count를 ++한 뒤에
이 사람은 지금 1개의 값에 대해서는 고려하고 있지 않음. 즉, 2개의 그룹으로만 구성하는 것을 원칙으로 하는듯 함.
1 1 100 1 같은 경우는
3 0에서 한번, 3,4에서 한번 걸려야 하고, 오히려 4에서도 한번 걸려야 함
생각해보면
100이 이미 들어간 이상
최대값 중 최소값은 당연 100이 되어야 함.
1 1 100 1 에서
(1 1) (100) (1)인 경우가 그룹상에서 가장 최소값이 되는 최대값인것.

그럼 최대값에서 최소값을 찾는 알고리즘을 다시 한 번 볼 필요가 있음.
결론 = 최대값의 최소값을 찾는 알고리즘이 문제.
Parametric Search(= 이분 탐색 + 그리디)
즉, 최적화 문제를 결정하는 문제로 (정렬된 데이터에서 최적해(그리디)를 찾아내는 방법)
으로 생각하면 될 듯 하다.
이분 탐색이기 때문에 시간 복잡도는 동일, 허나, low 값을 값이 나타낼 수 있는 최대점부터 시작하는 것이 포인트.
(즉, 조건 상에서 가장 기준값이 되는 부분부터)
이번 문제 같은 경우는 값의 최대해부터 시작하는 것이 맞음(list 상에서)
각 그룹이 제일 작게 나타날 수 있는 것은
자기 자신만 그룹일 때라고 생각한다. 그럼 거기서, 최대해를 찾으면 결국 list 상에서 가장 큰 값이 되는 것이다.
그래서 전체 최대해를 따질 때, 가장 큰 값은 전체 list 값의 합, 최저 값은 각 list 값 중 가장 큰 값이 되는 것이다.

이걸 이해했다면, 최대값의 최소값을 구하는 것은, 시간 문제.
앞으로 이런 특수한 알고리즘들은 정리해둬야겠다.


2606은 다익스트라 알고리즘을 활용하여 길이가 1인 거리를 활용하고,
start 지점을 1로 잡아 연결되어있는 (즉, 최초 설정값과 다른 값일 경우와 자기 자신을 제외한)
즉, 거리가 있기만 하면 전부 counting하면 이는 연결되어있는 것이랑 같기 때문에
이렇게 활용함. ㅅㄱ
