11286 절댓값 힙

절댓값 힙은 절댓값에 대해서 최소 힙을 적용하고, 절댓값이 같을 경우 최소 힙을 적용하는 힙의 구조를 만드는 것이다.
그래서, 기존 최소 힙의 판단 기준에, 절댓값을 넣은 뒤 절댓값이 같을 경우를 포함하여

만약 같을 경우 기존 최소 힙의 판단 기준을 적용해서 Heap을 구성하게 되었다.
말은 이렇게 하면 쉬운데, Heap 알고리즘의 대략적인 구조를 설명해야한다.

1. Insert
먼저 List의 끝에 해당 값을 추가한 후, 나의 부모 노드가 될 사람과 비교를 한다.
이 때, 맨 처음은 나와 내 부모 노드를 비교한 후 절댓값이 내 부모노드보다 크거나 같다면
일단 둘의 위치를 바꿔준다. 그런 식으로 올라가게 되서 내가 루트 노드가 되거나, 부모 노드보다 작다면 멈추는 구조이다.
여기서 비교 시 받아온 값을 계속 쓰는 이유는 잘은 모르겠으나, 답이 틀리진 않는 이유는 swtich를 해주기 때문에
실제로 값이 바뀌어있다면, 윗 부모 노드와의 지속적인 비교 후 값을 바꿔주는 것이 가능하기 때문이다.
여기서 절댓값 힙의 경우
절댓값이 같을 경우 최소 힙을 적용해야하므로, 절댓값이 같을 때를 한 번 더 비교하여 힙을 완성시켜준다.

2. Delete
일단 Root Node의 값이 가장 작으므로 이를 return 값으로 정해준 뒤 List를 재배열한다.
가장 먼저 할 일은 좌우 자식 노드 중 절댓값이 작은 값을 정해주는 것이다.
여기서도 만약 절댓값이 같을 경우는 최소 힙 과정을 한 번 더 거친 후 좌우 자식 중 Root Node를 정해준다.
그 뒤, 정해둔 노드에는 변화가 필요해지므로, 그 노드에 한정하여, 다시 한 번 자식들을 재배열하게 된다.
그런 식으로 Delete가 호출될 때마다 반복해준다.

문제를 이해하면 매우 쉬웠는데, 중간중간에 최소 힙의 기준을 다시 적용해줘야하는 부분을 다시 적용하지 못해서 이렇게 됬다.


---------------------------------------------------------------------------------------------------------------------------------------------


1715번 카드 정렬하기

처음에는 DP로 풀어보려고 했는데, 왜 DP로 풀려고 했냐면
잘못된 방법으로 접근을 해서다. list를 정렬해서 앞 값부터 2개씩 더해가면
원하는 값이 나올 것이라고 생각했는데, 3,4,5,6 처럼 3,4를 더한 후에 값을 봤을 때
5,6을 더하는 것이 가장 좋은 방법이기 때문에, 앞부터 2개씩 더하는 방법은 옳지 않았다.
그래서 고민해보니깐 우선순위 큐를 활용하면 좋지 않을까 하는 생각이 들어서
이 방법으로 해보려고 한다.

정답이었다. 우선순위 큐의 특성을 잘 활용한 문제였고, 완벽한 풀이였다고 생각한다.