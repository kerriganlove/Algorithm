10868번 최솟값

N~M번째 까지의 숫자중 최솟값을 구하는 문제.

최소힙 문제라고 생각해서 일단 풀어볼려고 한다.
최소힙을 구현해서 풀긴 했는데, 일단 시간 초과를 했다. 왜냐하면, list를 계속 PriorityQueue에 넣는 과정이 생겨서
O(N^2)의 시간 복잡도가 나오는 것이라고 생각했기 때문이다.

그렇다면 다르게 풀 수 있는 방법 혹은 시간을 줄이는 방법을 생각해보자.

세그먼트 트리라면 어떨까? 구현 방법을 알아내고, 각 트리의 값이 구간별 최소값이라는 결과가 나오면 되지 않을까
부분합을 구할때처럼 그 식만 바꾸게 되면 매우 쉬워질 것 같은데...

일단 정답은 맞는것 같은데 세그먼트 트리를 구성하는 법에 대해서 좀 더 공부해야할 것 같다.
아무래도 익숙하지 않았던 알고리즘인지라 제대로 구현하는 법을 다 까먹은 것 같다.
기본적으로 init, query를 구현할때, 범위를 벗어나는 행위, 범위 안에 있는 행위, 그 외의 하나의 패턴과도 같은 것에 대한
반복 숙달이 필요한 것 같다. 원리에 대한 이해는 덤.


================================================================


17608번 막대기

스택을 사용해서 맨 끝의 길이를 가져온 뒤 앞에서부터 비교해내가면서, 풀어가는 문제
간단하게 풀 수 있는 문제였다.
맨 먼저 맨 오른쪽에 있는 막대는 항상 볼 수 있으므로 count를 1개 늘려준 후 이를 기준값으로 삼고, pop한다.
그 뒤 pop을 반복하면서 기준값보다 큰 경우 새로운 기준값으로 pop된 값을 잡고 count를 늘려주는 방식으로
구현을 해주면 마무리 된다.


======================================================================

2776번 암기왕

stack이나 queue같은 자료구조는 아니다.
HashSet으로 풀어냈다. 중복된 값을 제거해준다고 해서, 실제 1번 케이스에서 누군가 본 숫자가
만약 중복이 되어있다면, 이를 제거하고, 단순히 본 숫자들만 카운팅 되는 것이 옳다고 생각했다.
그래서 만약 중복된 값이 필요가 없는 Counting이라면 HashSet을 고려해보는 것이 옳다고 본다. 일단은.


