10026번 적록색약

그냥 DFS로 각각의 영역에 대한 DFS를 해주면 되는 거였음.
그니까, R,G,B 그리고 적록색약이 있는 아이는 G를 R로 대체하여 볼 수 있는 영역으로
하나의 Map을 더 만들어서 각 Map의 R,G,B 영역을 각각 판단하여 영역인 부분을 ++시켜주면 되는 것임.
각 영역에는 일단 R이면 그 부분을 '0' 으로 만들어 주고, DFS 쭉 돌리면 R의 영역만 나오고
그 상황에서 G를 다시 돌리면 G의 영역이 나오고, B를 돌리면 B의 영역이 나오니깐 이를 전부 더 해주면 최종 값.
적록색약인 경우는 R,B 2개만 돌려주면 됨.
간단 그 자체인데 왜 이렇게 못 푼건지 잘 모르겠음.


10090번 Counting Inversions

swap되는 개수를 구하는 문제

인터넷을 찾아본 결과 합병 정렬이라는 것을 필요로하고, divide and conquer을 기본으로 한 정렬이라고 한다.
그래서 이번에는 한 번 배워본다고 생각하고, 합병 정렬과 응용한 방법을 배워서 코딩을 해보려고 한다.

배열을 계속 반으로 쪼개서 나온 왼쪽, 오른쪽 부분 배열에 대해서 정렬을 계속 하는 것.
여기서 counting inversion을 구하는 방법은 왼쪽과 오른쪽 부분 배열을 비교할 때, 만약 오른쪽 값이 더 작다면
정렬이 되어야하는 부분이기 때문에, ans를 더해주면 되는데, 이 ans는
왼쪽이 가리키고 있는 값 > 오른쪽이 가리키고 있는 값
이라고 하면, 그 후의 왼쪽 배열이 가리키는 값이 오른쪽이 가리키고 있는 값보다 크다라고 할 수 있으므로
전체 크기에서 현재 가리키고 있는 크기 만큼은 무조건 ans가 되는 것이다.
이런 식으로 왼쪽과 오른쪽의 병합 정렬을 구해주면서, 최종적으로 병합이 되면,
모든 정렬이 되면서, 실제 숫자가 inversion되는 숫자를 구할 수 있는 것이다.

이 원리는 블로그에서 본 코드를 해석해보면서 merge sort를 구현해봤음.
분할 정복의 아주 일부분을 해본 것 같아서 기분이 좋음.


