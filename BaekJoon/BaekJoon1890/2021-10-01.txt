3090번

이분탐색의 조건을 파악하는 연습을 필요로 하는 문제.
여기서는 middle의 값이 인접한 수의 차이를 뜻하며
이 차이의 최댓값을 최소로 하는 것이므로
-1 연산의 횟수를 연계하여 이 횟수보다 클 경우와 작거나 같을 경우를 나눈 뒤
만약 횟수가 작거나 같을 경우라면 middle 값의 범위를 작게 좁히고
클 경우 middle 값의 범위를 크게 좁힌다.

그렇게 해서 나온 마지막 end 값이 결국 연산 시 인접한 수의 차이의 최대값 중 최솟값이 되므로
이를 적용시켜주면 된다. 아이디어가 어려운 문제.

----------------------------------------------------------------------------------------

1890번 점프

골조는 DFS였다고 생각해서 DFS를 활용해서 문제를 풀었는데, 답은 맞으나 시간 초과가 났다.
그래서 visited를 활용했는데 이건 생각해보니 dp에 값이 제대로 들어가지 않을 것 같았다.
사람들은 DFS + DP를 활용해서 문제를 풀었다고 했다.
그렇다면 DP의 점화식이 있을 건데 그걸 모르겠다.

일단 음... 답은 맞았고 이해를 좀 해야할 것 같다.(정확히는 답도 내께 아님.)
결국 DFS(0,0)을 돌리는 것은 당연히 맞았다.
그 과정에서 dp 배열을 만들기 위한 사전 작업이 중요했는데.

골조는 역시 visited를 쓰는 것은 동일했다.
그리고 끝에 도달했을 경우 +1을 return 해주는 것 또한 같았다.
그러니까, 이건 bottom-up 방식인 것 같다.

dp[0][0] 에서 dp[n-1][n-1]까지 bottom-up을 통해서 푸는 방식으로
dp[0][ny] dp[nx][0]이 각각 범위를 벗어나지만 않는다면
DFS를 활용하여 dp[n-1][n-1]에 도달하면 1을 return하고, return된 값은 x + dir , y + dir을 하기 전의 dp[x][y]에 더해주는 방식이다.
여기서 visited를 활용해야하는 이유... 이게 좀 의문이긴 한데
dp map에서 만약 그 지점을 이미 방문했다는 것은 그 이후의 경로에 대해서는 이미 다 count가 되어있다라는 뜻이 되므로
만약 이를 그냥 넘겨버리게 될 경우에는 값을 2번 계산하는 경우가 되어 값이 달라질 수 있다고 생각했다.
그래서 마지막에 dp[x][y]를 그냥 리턴하게 되면서 그 이후의 경로 값은 다 계산이 되어있다고 확정하는 것이다.

뭐 여튼, 답을 알고 봐서 쉽긴 했지만, DFS + DP를 활용함에 있어서 dp의 값을 먼저 계산한다는 등의 어리석은 발상은 안했으면 좋겠다.
그리고 문제가 쉽긴 했는데, 이런 실수를 반복하면 안된다는 생각을 하게 되었다.

