9251번 LCS

맨 처음 생각은 모든 경우의 수를 다 구하는 방법이었다.

그러나 경우의 수가 너무 많았다.

어차피 문자열의 길이만큼의 경우의 수를 구하는 문제이므로
2^n -1 이 될 것으로 생각했다. 그런데 이렇게 하면 분류가 까다롭고, 길이가 너무 길어 모든 경우를 다 비교하기가 힘들었다.

그래서 분류를 보니 DP였는데, 메모이제이션부터 Top-down, Bottom-Up 중 어떤 방식을 택해야하는지 감이 잡히지 않았다.
그래서 설명을 첨부한다.

메모이제이션의 방법은 Bottom-Up이라고 보면 될 것 같다. 작은 문제를 해결하여 값을 쌓아가는 방식이니까.
작은 문제는 다음과 같다.
두 문자열을 편의상 A,B라고 부를 때, A의 문자열 위치의 문자와 B 문자열 위치의 문자가 같을 경우라면
그 전, 즉, A,B 두 문자열의 전 위치에 대해서 같았던 개수를 return한 뒤 그 값에 +1을 해주는 방식을 취한다.

이게 무슨 말이냐면, 두 문자열의 포인터를 한 칸 뒤로 옮겨서 그 때까지 풀어놓은 작은 문제들의 값(같은 문자의 개수)을 찾아
자신들의 위치 역시 같은 문자이기 때문에 +1을 해준다는 것이다.

만약 같지 않다면, 각 문자열들을 각각 뒤로 한 칸씩 보낸 뒤 같은 문자열의 개수가 큰 것을 반환한다.
이건 가장 긴 길이를 위한 과정으로써, 먼저 A 문자열을 한 칸 뒤로 보내 그 위치에서 그 동안 같았던 문자의 개수를 반환하고
B 문자열을 한 칸 뒤로 보내 그 위치의 같은 문자 개수를 반환해서 둘 중 큰 값을 고르는 것이다.
이렇게 하게 되면 그 위치에서 가장 긴 문자열을 return 받게 되는 것이라고 생각하면 될 것 같다.

9252번 LCS 2

기존의 방식과 동일해지지만 여기서 LCS의 문자열까지 출력을 해야한다.
내가 생각해본 방법은 다음과 같다.
어차피 최댓값을 계속 반환하고 있기 때문에 DP의 값이 변화한 순간의 문자를 순차적으로 반환하면 결과값이 나오지 않을까?

변화한 순간을 채용하려고 했는데, 그렇게 되면 최대의 길이의 문자열이 반환되는 것이 아니라
최초로 문자열이 같은 순간을 채용하기 때문에 만약 A의 문자열과 B의 문자열이 최초로 같게 되는 위치가
LCS가 아니게 된 경우를 Count하기 때문에 아니다.

그래서 아예 끝에서부터 천천히 추적하는 것 또한 생각을 해보긴 했는데 그건 아닌거 같다.

그건 아닌줄 알았는데 맞았다.

대강의 역추적 방식은 이러하다.
1. 만약 A,B 문자열의 현 위치 문자가 같을 경우, 값을 문자열에 대입해주고, 대각선에서 값이 온 것이기 때문에 현 위치를 왼쪽 대각선으로 옮긴다.
2. 만약 A,B 문자열의 현 위치 문자가 다를 경우, 여기서 DP의 값은 왼쪽, 혹은 위에서 온 값들 중 최댓값이기 때문에
이 둘 중 같은 값을 찾아서 해당 위치를 옮겨준다.

한 마디로 도착점을 기준으로 역으로 추적해서 값을 계쏙 옮겨주는 길 찾기 같은 문제이다.
