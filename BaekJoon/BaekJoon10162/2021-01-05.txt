5719번 거의 최단 경로

다익스트라를 구현한다. 문제는 최단 경로로 가는 길을 제외해야 한다는 것인데

1회차 다익스트라 때 최단 경로로 갈 수있는 경로를 전부 없애버리고
그 상태에서 2회차로 갈 수 있는 경로를 다시 다익스트라로 돌리면 최적값이 나오긴 함.

1회차 다익스트라때 어떻게 값을 저장하고 없앨 것인지에 대해서 고민을 해야함.
cost가 제일 작은 걸 골라내는데, 경로 저장을 어떻게 할 것인가가 중요하네...

아니면 다익스트라를 1번돌리면서... 는 안되겠지?

edge 자체를 없앤 상태에서 다익스트라를 돌려야 되는 것이니깐...

일단 알고리즘

start점 받아와서 다익스트라 함수 대입, end 점은 distance 판별에 사용.
INF면 사실상 갈 수가 없기 때문에 2번째 다익스트라는 할 이유가 없음.
INF가 아니면, 그 거리를 가기 위해 거쳐온 edge를 삭제해야함. ( 핵심 요소 )
그러고 다익스트라를 한번 더 돌려서
똑같이 INF, !INF를 따져서 INF면 -1, 아니면 그냥 그 거리 값을 내보내면 됨.

그 거기를 가기 위해 거쳐올 수 있는 edge를 어떻게 저장해둘까
나한테는 그게 핵심임.

다익스트라를 통해서 경로를 역추적 할 수도 있음.
이 때, 나는 edge 자체를 역추적 해서 이를 완전히 삭제시킬 예정.

아이디어 자체는 잘 세웠고, 여기서 BFS를 활용하는게 메모리 시점에서 초과가 나는거 같은데

하... BFS는 맞았고, visited를 계속 도는 문제가 생겼던 모양임.
visited를 1번만 방문하게끔 하기 위해서 !visited일때만 들어가도록 하니깐 바로 정답임...
아... 개빡치네 ㅋ

------------------------------------------------------------------------------------

10160번 암호

ABABC와 ABCBC가 들어가는 패턴을 제외하고, 나머지 숫자의 경로를 구하라.
DP 같긴 함. 결국 dp[n] = dp[n-1]가 될 거 같아서

패턴에 들어간 문자 이후에 1글자를 더 추가해야되는 과정이므로,
5글자인 경우는 2가지를 제외하면 되고
dp[5] = 1*2;
dp[6] = dp[5]*K의 개수*2(*2는 들어갈 자릿수)
dp[7] = dp[6] * K의 자릿수 * 2(들어갈 수 있는 자릿수)

여기에, 지금은 K가 3이지만, K가 N일때의 경우도 구해야함.

그렇게 한 다음에
K^N-dp[N] % 1,000,000,009로 나눈 값을 넣어야 함.
이 때 dp도 그 값이 커질수가 있어서 똑같이 값을 넣어야할 듯 합니다.
K^N % 1,000,000,009 - dp[N] % 1,000,000,009를 해야함.

근데 문제가 이게 아닌건가... 싶어서 일단 보류해놓음. 곧 문제를 제대로 이해한 뒤에 한번 더 볼 예정.
(아마 ABABC ABCBC에 따라서 ABAB뒤에 C가 오지 않으면 되고, ABCB 다음에도 C가 오지 않으면 되므로 뭐 이런식으로 해서
경우의 수를 구할 것 같음. 내 DP는 그럼 겹치는 부분이 있어서 이렇게 되는건가? )

------------------------------------------------------------------------------------------------------

10162번 전자레인지

ez한 문제고, 그리디 문제이다. 가장 최적의 값을 찾으면 됨.
5분, 1분, 10초가 주어졌을 때 이 값을 가장 큰 값으로 먼저 빼주면 됨.
난 그 조건을 몫이 0이 아닐때까지 300, 60, 10으로 각각 나누면서
몫이 0이 될때까지 이 값을 빼줌

그럼 값이 나옴. ㅅㄱ


