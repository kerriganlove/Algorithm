5014번 스타트링크

s->g까지 가는 길에 u,d 버튼만을 사용하여 움직여라.
단, 갈 수 없다면 특정 글자를 출력하라.

내가 생각하는 것

s > g 일 때,

s < g 일 때

반복문의 끝나는 조건은 s == g일때인데
만약, d가 아까와 같이 0이면 무한루프가 돌아감
이를 위한 조건이 필요할 것.

모르겠어서, 값을 보니 BFS를 활용하는 것이었다.
근데 BFS를 어떻게 활용해? 라는 느낌이 왔다. 왜 활용을 해야하는가
단순히 최소값이기 때문일까? 그리디로는 푸는 문제가 아니라서 그런 걸까
어쨌든 이를 활용해서 문제를 풀자면, Queue에는 판단이 끝난 층이 들어갈 것.
그래서, 만약 목표층에 도달했다면 true, 아니면 false를 반환(while문이 끝났다면)

좀 더 고민해봐야할 문제인 것 같았다. 아직 내 머리 속에서는 이 문제가 BFS로 풀려야하는 정확한
이유를 설명하지 못하기 때문이다. 물론, for문 2번을 돌려서 완전 탐색을 하면서 찾지는 않을 것이지만,
뭔가 그리디스럽게 풀 수 있는 문제 같았는데, BFS라는 최소 경로 찾기 시스템이 활용되니 조금 당황스럽다.
조금 더 공부를 해봐야할 것 같다.

-------------------------------------------------------------------------------------

5052번 전화번호 목록

일단 내가 생각했을 때는 KMP 알고리즘을 활용하는 것이 가장 알맞다고 생각
근데 문제는 모-든 문자열들을 다 비교해봐야하는 것.
그렇게 되면 for문으로 생각하면 10000*10000이 나오는 것인데
NlogN이라서 내가 알기로는... 10000*14 정도 나오는듯?
일단 만들어보고, 결정하겠습니다.

KMP로 만들면 각 문자열에 대해서 모두 검색을 해야하기 때문에 뭔가 이상해서
분류를 봤을 때 생소한 Trie 알고리즘이 나와서, 이를 구현해보는 방향으로 설정을 할 것입니다.
일단 Delete는 현 과정에서는 없기 때문에 delete를 제외하고 나머지 부분을 구현해보겠음.

Trie 알고리즘은 Tree를 이용해서 1글자씩 빌드업하는 느낌으로 저장하는 거임
즉, Hello, Find를 저장하면

H-e-l-l-o, F-i-n-d 같은 개념으로 트리를 저장시킴.
그리고 끝 글자를 판별시킬 수 있는 Boolean을 넣어, 이 자리가 끝인 자리를 먼저 판별해둔다.

그리고 문제에 적용하는 경우 같은 것은 접두어로써 이게 가능하냐? 라는 점을 미루어 보았을 때,
앞에서부터 차례차례로 보면서, 이게 만약 한 단어의 끝이 된다면, false를 반환(접두어기 때문에)
그렇게 풀었음.


