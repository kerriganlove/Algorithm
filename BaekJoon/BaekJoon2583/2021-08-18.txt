2636번 치즈

기존에 풀었던 토마토와 똑같다고 보면 될듯?
그런 줄 알았는데 아니었음. 치즈에 구멍이 있고, 그 구멍은 공기가 통하지 않아
주위가 썩지 않는다.
문제를 풀때는 제약조건을 잘 봐야한다. 왜 틀린지를 그래서 알게 되었고,
그 부분을 해결하기 위해서 어떻게 해야하는지 연구를 했지만
처음에는 영역의 개념이었기 때문에 DFS로 해야한다고 생각했지만 그 영역만 변경하지 않아야 할 수 있는 조건을
모르겠어서 결국 찾아보게 되었고, 영역을 BFS를 돌려 정의하는 것을 보았다.
일단 시간 자체가 O(N3)을 넘겨도 크게 문제될 게 없었다고 생각은 했다. 그런 생각을 통해서 보니깐
역시나 제약 조건에 따라서 코드를 짜는 법을 좀 배워야할 것 같다는 생각이 들었다.

크게 2가지의 BFS를 돌린다.

1. 공기를 만드는 BFS
2. 바뀐 Map을 통해 Cheeze를 공기로 바꾸는 BFS

여기서 1,2번의 각각 조건들 때문에 조금(많이) 헤매기는 했지만, 공기를 만드는 BFS에서는 진행을 위해서 그 주위가 전부 공기라도
Queue의 요소에 추가하여 공기가 아닌 부분을 찾아가야했다.

치즈를 공기로 바꾸는 BFS에서는 이렇게 했었다. 나는 치즈를 기준으로 삼아서, 치즈 주위가 공기라면 무조건 변하도록 하였다.
그 대신 그 치즈는 그 BFS동안은 다른 치즈를 공기로 바꿀순 없으므로 그 치즈의 위치로 가지 못하도록 boolean 변수를 통해서 막았다.
그 뒤, 치즈를 공기로 만들었다면, 다시 Queue에 그 위치를 저장하면 끝인데, 사실 이렇게 안해도 된다.
왜냐하면 조건에 걸리지 않는 애들이 결국 -1이 되지 않기 때문에 Map 상에서도 살아있고,
그렇게 되면 2번째 BFS를 돌릴때 자연스럽게 1인 애들이 다시 Queue에 들어오게 되는 구조가 된다.

글을 쓰다보니깐 또 뭔가 비효율적인 움직임을 한 것 같아서, 반성을 해야할 것 같다.
생각을 해보면 굳이 O(N^2)을 해서 1인 애들을 다시 Queue에 넣는 것을 했어야 했나? 이런 생각은 든다.
뭐 비슷했다고 생각하지만, 좀 더 효율적인 코드를 짜야할 것 같다.

이런 문제에 시간을 잡아먹는 이유는 1. 제약조건을 제대로 몰라서, 2. 알아도 구현하는 방법이 헷갈리고, 그러다보면 보이는 것도 안 보이는 사태가 발생.
이 정도인 것 같다.
쉬운 문제였고, 정답률도 높았던 문젠데, 빠른 시간내에 풀지 못한것이 너무 아쉽고, 이렇게 가면, 코딩 테스트는 또 물 건너 갈 것 같다.
정신 차려야한다.


---------------------------------------------------------------------------------------------------------------------------------------------


2583번 영역 구하기

내가 생각하고 있는 방향은 먼저 주어진 직사각형을 벽으로 친다고 생각하면,
DFS를 통해서 영역을 구하는 문제와 다를바가 없고, 거기서 내가 풀어봤던 DFS 문제는 영역의 개수를 지정하는거라면,
이번에는 그냥 true가 넘어오면 num을 반환하는 형식으로 해보면 될 거 같다.

내가 생각했던건 맞았고, 답이 한 번 틀렸던 건 HashSet에서 동일한 숫자가 들어가니깐 그냥 씹혀서 자동 정렬이 안됬음..
그래서 ArrayList로 가변 배열을 만들고 다 추가한 후에 Collections.sort를 통해서 배열을 정렬하였고,
그 뒤에는 정답 판정을 받았다.

영역을 구하는 문제는 DFS가 내 입장에서는 훨씬 편한 것 같다.
물론 전 문제 같은 경우는 영역을 구해도, 그 영역이 구멍인지 아닌지 판단하기가 너무 까다로워서 BFS로 풀었지만,
단순히 어떤 영역에 제약이 크게 없다면, DFS로 영역을 구하고, 그 영역 안에서 계산할 수 있는 부분을 계산하는게 좋아보인다.
