1865번 웜홀

어제 풀려다 못 푼 문제로 그래프 최단 거리 탐색에 쓰는 벨만-포드 알고리즘의 응용이다.

벨만-포드 알고리즘의 세부적인 동작 부분을 다시 한 번 공부해봐야겠고,
음의 사이클이 있다고 판단이 되면 일단 벨만-포드를 먼저 생각하는 것이 옳다.

내가 참고한 블로그에서는 2가지의 방법을 제시하였다.
1. 모든 정점에 대해서 벨만-포드 알고리즘을 통해서 검사하는 방법.
2. 출발점을 1로 삼고, 각 지점에서 음의 사이클이 일어나는지 판단하는 방법.

2번이 더 간단한 방법이지만 왜 이렇게 되는지 또한 알아야한다.
1번 같은 경우는 정말 정직하게 모든 출발점에 대한 음의 사이클을 조사해서 만약 나오게 되면
YES를 반환하는 식이었다.
그러나, 일단 어떠한 방식에서든 내가 한 정점에서 다른 정점으로 간 거리가 줄어들었다는 판단은
(어차피 웜홀은 단방향이니까) 내가 그 거리를 갔다가 돌아왔을 때의 총 거리가 -가 됬다고도 볼 수 있는 것이다.
어차피 시간만 줄어들면(출발시간과 도착시간이 같던 뭐 다르던) 출발하고 나서 다시 이 정점으로 돌아온 시간이
실제 돌아오기 위해 가야했던 거리보다 (양방향이기 때문에) 줄어들었다면, 음의 사이클이 있는 것이다.

아직 좀 더 이해가 필요한 것 같아서 일단 이정도로만 생각하지만, 일단 왜 아무 정점을 잡아도 음의 사이클이 나오면
시간이 줄어든 것이라고 판단할 수 있는지에 대해서는 어느 정도는 이해가 간다.
벨만-포드 알고리즘은 한 지점에서 다른 지점으로 가는 최단거리를 음의 간선을 포함해서 나타낼 수 있는 방법인데,
여기서는 모든 지점을 기준으로 삼았고, 만약 한 지점에서의 음의 사이클이 일어나지 않았다고 가정하면,
다른 지점에서의 음의 사이클이 일어났다는 것을 어떻게 증명할 것인가.
이게 내가 이해해야 하는 문제점이 아닌가 싶다.

---------------------------------------------------------------------------------

8741번 이진수 합

이딴거 필요없이 패턴만 알았으면 아주 쉽게 해결되는 문제.
k자리 이하의 모든 자연수를 더한 값을 살펴보면
k개의 1과 k-1개의 0으로 이루어진 숫자라는 것을 알게 됨.
즉, 앞에서 k개만큼 1을 붙여주고, k-1개만큼 0을 붙여주면 끝.
그러면 28 = 11100, 120 = 1111000 이 되는 것이다.
