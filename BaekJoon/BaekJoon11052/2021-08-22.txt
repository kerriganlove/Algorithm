2156번 포도주 시식

연속으로 놓여진 3잔을 마실수 없다. ( 2잔까지는 허용 )
반드시 다 마셔야 한다. 

맨 뒷 상황을 기준으로 해보자.

그렇게 되면 맨 뒷 상황은 총 3가지로 구분이 된다.
1. 맨 뒷 자리만 선택된 경우
2. 맨 뒷자리와 그 앞자리가 선택된 경우
3. 아예 선택되지 않은 경우.

그래서 점화식을 세워봤다.
dp[i] = max(dp[i-1], list[i] + dp[i-2], list[i-1]+list[i]+dp[i-3])

식으로는 2가지로 표현했지만 이렇게 하면 맞더라고
여기서 dp 배열의 의미는 그 자리까지의 최대값이라고 보면 된다.
즉, dp[4]는 4칸까지 내가 최대로 먹은 포도주의 양이라고 보며 된다.
이 때, dp[1], dp[2]는 미리 계산을 해주는 것이 편하다.
dp[1]의 경우는 무조건 그 칸을 먹어야만 하고
dp[2]의 경우는 첫번째 두번쨰 전부를 먹어야 최댓값이기 때문이다.


--------------------------------------------------------------------------

11052번 카드 구매하기

어... 그리디인줄 알고 풀었는데, 반례가 좀 있음.
나는 카드 가치 / 카드 번호를 통한 Backpack의 개념인줄 알았는데, 이게 한 가치가 살짝 더 큰데, 실제 저 카드 가치/카드 번호를 통한
greedy 문법이 통하지 않을 수 있어서 (ex ) 3 1 100 103 일때, 3, 103을 고르는게 좋은데, 알고리즘 상으로는 100,1을 골라 101이 됨.)

다른 방법을 생각해봐야할 것 같다.
그래서 전에 했던게 DP니깐 dp로 생각을 해보니깐 아주 간단하게 풀렸다.
각각의 dp 배열은 자기 자신의 값을 가지고 있다. 이는 현재 그 가치를 그 카드 하나만으로 채웠을때의 값이라고 하자.
그 뒤, dp[N] = max(dp[N], dp[i] + dp[N-i])를 반복한다.
왜 이렇게 되냐면, dp[i]는 결국 가치가 i인 값의 최대값이기 때문에, 앞을 i칸, N-i칸 채웠으면, 결국 N칸을 채운 것이기 때문에
이 중 최대값을 찾아내면 간단하게 풀리는 문제이다.

