1541번 잃어버린 괄호

일단, 문제를 잘못 이해했다. 괄호를 단 1개만 사용하는 것인줄 알았는데, 그게 아니라
괄호를 적절하게 몇 개를 치던 상관없이 가장 최솟값을 만들어내는 문제이다.
이는 그리디 문제로 생각하고, 문장을 보면, 결국 가장 최솟값이 될 수 있는 건
뺄셈 바로 뒤에서 다음 뺄셈이 나오기 전까지의 모든 값을(더하기가 몇개건, 심지어 숫자가 1개건)
괄호를 쳐서 미리 그 값을 계산한 후 뺄셈을 진행하면 가장 최솟값이 나온다.

괄호 1개만 가지고 어떻게 하나 고민 엄청 하다가, 찾아보니깐 괄호를 다수 쓸 수 있다는 것을 본 순간
너무 쉬워진 문제.

------------------------------------------------------------

1520번 내리막 길

BFS로 최단거리를 찾는 문제는 아닌거 같은데
각 좌표의 위치와, Key값을 Queue에 넣고
그냥 작으면 Queue에 계속 넣어서 맨 끝까지 오면 answer++;

그렇게 하면 될듯
어.. 근데 BFS를 썻는데 메모리 초과가 떴어요...
그래서 분류를 보니깐... 다이나믹 프로그래밍이네요...?
그럼 점화식을 세워야겠죠?

답을 dp[M][N]으로 채웠을때(여기까지 올 수 있는 경우의 수라는 개념으로)
일단 맞긴 한데, DFS를 이용하는 방향이었어야 함.
DFS를 통해서 이어지는 구간을 그려가는 식으로 표현했어야되는 것.
그 때, DFS는 이미 지나온 구간을 탐색할 수도 있으니, 탐색한 곳은 더 이상
탐색하지 않는다는 의미의 표시를 하나 해준다고 생각하면 됨.

