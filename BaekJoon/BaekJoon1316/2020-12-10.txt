2512번 예산

일단 문제를 보자마자 이분 탐색이라는 것은 부정을 할 수 없었음.
특정한 예산의 범위를 구해야하고, 가장 최대의 예산을 배정해야하므로
특정한 예산을 이분 탐색을 통해서 구하고, 그 값보다 큰 값을 대체하여 더해보면서
풀어보면 됨. 풀이 방법은 이러하고, 풀이를 하면서 주의할 점

1) 최소 예산은 0원부터 
왜냐하면, list의 금액에 대한 단순 비교이고, 그 값을 대체하지 않기 때문에
혹시나 기존 budget이 현재 시에서 요청한 최소 금액보다도 작게 되면
이분 탐색이 제대로 돌아가지 않음. 그래서 0원부터 잡아서 조금 더 많이 계산해도
값이 나올 수 있도록 했음.

2) while 종결 및 start, end 값 수정 시
while 종결은 항상 start > end 일때만 가능하게 한다. start=end=mid 일 때도
현재 mid 값을 통해 더해놓은 값이 total보다 크다면, 이는 의미가 없게 된다.
그래서 만약 크게 되면 end 값을 1개 줄여서 정답을 출력하는 것이다.
그리고 start,end 값은 항상 그 값은 비교가 되었던 것이므로, start은 1 크게, end는 1 작게 선언한다.
그리고 start,end를 정하는 기준도, end는 항상 total보다 크게, 그게 아니면 start에 머물도록 했다.
그게 맞더라.

-----------------------------------------------------------------------

2805번 나무 자르기

똑같은 이분 탐색이고, 이것도 마찬가지로 순서를 정한 뒤에 0과 제일 큰 값을 기준으로 삼아
이분 탐색을 실시하며, list-높이 < M -> start 올리기
list - 높이 >= M 일단 낮추기

쉽게 ez하게 해결함.

-----------------------------------------------------------------------

1361번 그룹 단어 체커

최대 100개의 단어에 대해서 이 단어에 있는 알파벳들이 연속적으로 나타나느냐
를 정하는 것.
나는 이 문제를 어차피 완전 탐색으로 풀어도 단어의 길이가 길지 않아서 가능할 것이라고 생각함.
일단 1번에 통과함, 너무 쉬움. 문자열을 기준으로 삼았을 때
나는 그 전값과, visited라는 boolean형 배열을 알파벳 숫자만큼 선언해줌.
그래서, 전 값을 한 변수에다가 항상 저장해주고, visited에는 알파벳의 위치에 따라서 맨 처음 방문하면 true로 바꿔주는 역할을 함.
그래서 맨 처음 방문할 때는 visited를 true로 만들고, 전 값을 저장해줌.
그리고 만약 true라면, 전에 저장해둔(즉 연속적이어야할) 문자가 현재 위치의 문자열과 맞지 않다면,
당연스럽게도 중간에 한 번 끊긴것이기 때문에 그대로 결과값이 0이 됨.
만약, 이 루틴을 통과하면 연속적인 문자열이므로 1을 반환하게 함.

결과 : 정답. 단순히 100자리 정도의 문자열이면 이런 식으로의 구현, 문자열 관련으로 보고 행하면 됨.
시간 제한이 없다면 특히 더 이런 식으로 하면 됨.