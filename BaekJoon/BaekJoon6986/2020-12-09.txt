6986번 절사평균

틀린 이유를 모르겠음. 부동 소수점 때문에 BigDemical로 바꾸고, 심지어 값이 들어가는것 또한,
그냥 실수로 하면 연산이 잘 안된다고 해서 최초 array에 String 형태로 집어넣었음.
계산 과정도 무조건 맞고, 뭔가 계속 통과를 못하니까 짜증이 좀 남.

결론 : 첨가하는 변수에 대해서 잘 알아보자.
만약 이 문제를 리뷰하게 된다면, RoundingMode에 대해서 자세히 설명을 해둬야할 것 같다.
부동 소수점의 오차를 최대한 해결하기 위해서 모든 변수들이 계산될때는 항상 String 형태로 정확하게
나올 수 있도록 구현하였으며, 이 과정에서 조금 느려지기는 하지만, 완벽한 결과가...
나올줄 알았으나, 8번~9번 정도 틀리고 통과하였다.
전부 60% 단계에서 탈락하길래 여러 요소들을 바꿔보았고, 결국 RoundingMode에서 반올림을 하는
과정이 잘못 되었다는 것을 알았다. RoundingMode.HALF_UP, HALF_EVEN은 같은 반올림이지만,
HALF_UP은 0.5에서도 반올림을 해주고, HALF_EVEN은 이를 처리하지 않았다.
보통 우리의 상식으로는 0.5는 반올림해서 1이기 때문에, UP을 사용해본 결과 맞았음.
괜히 어디서 EVEN이 반올림이라는 걸 봐서 이만큼 틀린 것 같아서 억울하지만 풀었으면 그만임 ㅋㅋ


6987번 월드컵

간단하지 않을까?

승 무 패 3개의 개수가 실제 경기와 일치하면 되지 않을까?
승, 패는 사실 6을 넘지 않기만 하면 모든 경우의 수가 가능하다고 생각함.
5가 있다고 해서 1,0이 없을 경우는 없다는것, 그니까 짝이 맞지 않아도 개수만 일치하면 맞을 수 있음.
선제로 판단함(승 = 패)
그리고 drawSum은 draw의 수를 계산한다. 그래서 실제 (전체-승+패 != drawSum)
을 전제로 둔다. 그리고 draw에 대한 판별은 이루어져야 함.
drawSum은 홀수가 될 수 없고(짝이기 때문에), 

간단하긴 하지만, 완전 간단하지는 않다라는 느낌? DFS를 이용해서 BackTracking 시도,
그리고 전체 탐색은 모든 경우의 수를 다 둘러보는 것(완전 탐색)

위의 경우의 수는 너무나도 다양하고, 어떠한 공식으로 정해질 수가 없으므로, 이런 경우
즉, 뭔가 어떠한 공식을 찾을 수 없는 경우가 되면, 기본적으론 완전 탐색이 옳다.

