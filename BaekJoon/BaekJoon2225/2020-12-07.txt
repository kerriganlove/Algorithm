2225 합분해

-> 0~N까지 K개의 정수를 써서 N을 만들어라
-> 숫자의 순서가 바뀐것 또한 경우의 수로 친다.

처음 생각한 것. 개수를 제한한 부분합의 개수를 구한 후 * factorial(N)
1) 부분합을 어떻게 구할 것인가

----------------------------------------------------------------

dp로 풀래요... 그럼 점화식을 세워야함
일단 생각한대로 dp[k][N] 이긴 했음.
그러나 그 세부적인 사항에 대해서는 생각하지 못함.
dp[k][n] = k개의 수로 n을 만드는 경우의 수
자, 여기서 볼 게 있음. 이걸 생각해보면
기존 dp[k-1]에서 n보다 작은 경우의 수를 만들게 되면(이걸 l이라고 하면)
다음 dp[k][n]은 dp[k-1][n-l]을 기준으로 l의 변화에 따라 0~n까지의 숫자를 계산하면 되는 것이다.
다음 1개의 숫자가 들어옴으로써 비로소 n 값이 될 수 있는 경우의 수를 구하는 것이므로
예를 들어(1+2) 다음 4를 만들 수 있는 값은 1이 된다.
마찬가지고 (2+1) 역시 1, (0+3) 역시 1, (3+0) 역시 1이 된다.
이러하게 앞에서 3을 만들 수 있는 경우의 수를 모두 더해주는 방식, 그리고
2일때도 마찬가지... 라고 생각하면 결국 점화식은 dp[i][j] = dp[i-1][j-l] (0<=l<=n) 이 되는 것이다.

-----------------------------------------------------------------

2252번 줄 세우기

위상 정렬로 푸는 문제, 여기서 위상 정렬은 꼭 필요한 정렬만 수행하는 알고리즘으로
지금과 같은 경우는 2개의 숫자가 정렬의 기준이 된다.
여기서 그 위상을 적용하기 위해서, degree 정렬을 통해 정렬되어야 하는 숫자를 미리 저장해둔다.
a,b 형태로 들어오는 정렬의 기준에서 뒤에 오는 숫자에 대한 각각의 개수를 구한다.
예를 들어, 1,2 1,3이면 degree[2],[3]에 각 1을 추가한다. 그리고 맨 처음 고려해야할 숫자를
degree가 없는, 즉 언제든 앞에 올 수 있는 숫자를 queue에 추가한다.
그 후 고려해야할 숫자에 대해서 뒤에 오는 숫자들이 있는지 판별하고, 만약 있다면
degree배열에 있는 숫자를 하나 줄인다. 이는 정렬 조건 1개가 끝났다고 보면 된다.
그래서 그 후 degree 배열에 있는 값이 0이 되면, 정렬이 끝났다는 것이므로, queue에 그 조건을 추가하고
출력하면 된다.

솔직히 위상 정렬을 잘 써보지 못해서 아직도 이해가 잘 가지 않지만, 나름... 잘 푼거 같기도 하고 잘 모르겠음.
