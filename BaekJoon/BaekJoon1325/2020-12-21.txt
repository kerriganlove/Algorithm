1300 K번째 수

1. 정렬되어있고, 일차원 배열이면 일단 이분 탐색을 의심해보자

2. 그러나 조건을 찾는게 나는 좀 어려웠다.
어제처럼 수학 공식을 이용하는 느낌으로 했었다면, 더 좋았을 것이다.
행렬에서 각 행에 대한 값을 mid/i로 표현하는 것과 같은
생각들을 빠르게 하는게 중요할듯. 확실히 유연한 사고가 많이 필요하다.

3. 이분 탐색임을 처음에 언급한 것도 많이 발전됬다고는 생각함^^

--------------------------------------------------------------------

1325 효율적인 해킹

일단, 내 생각에는 플루이드 워셜 알고리즘을 활용하면 되지 않을까?

1~N까지의 모든 경우의 수를 구해야하므로, (단, 단방향이어야하고)
어... 근데 플루이드 워셜 알고리즘이 아니네요?
그냥 단순 DFS입니다...

하긴... 최단 경로를 구하는 문제가 아니라 단순히 갈 수 있냐 없냐만 판단할 수 있는 문제니깐
굳이 플루이드 워셜로 모든 경로를 구할 필요성이 없는거죠...

DFS+DP 개념으로 풀었는데... 솔직히 잘 모르겠고, 집중도 안되서 그냥 풀어만 놓고
접는다는 마음가짐...

