2108번 통계학

그냥 아이디어 문제인데, 최빈값에 대한 아이디어가 부족했다.
다른 3개는 전부 Sort를 통해서 간단하게 해결할 수 있는데,
이를 검색해보니까 counting 배열을 하나 써서 O(N)으로도 해결 가능한 듯 하였다.
나는 최빈값만 그 아이디어를 차용하여 counting 배열을 따로 만들어뒀다.
counting 배열을 사용하면 중앙값을 뽑는게 어렵기도 하니깐
두개를 전부 썼다고 그냥 생각하고, 시간이나, 메모리나 전부 초과나지 않는 선이라고 생각했다.

최빈값같은 좀 단순한 알고리즘들은 그냥 내 생각대로 구현해보는게 좋을 것 같다.

-----------------------------------------------------------------------------------------

2133번 타일 채우기

예전에 풀어봤던건 세로가 2였던 거고, DP 점화식을 해결해서 문제를 품.

그러나 홀수일때의 경우의 수가 있냐라는 질문을 하게됨.
3x1을 2x1과 1x2로 채울 수 있는 경우의 수가 있나?
없음. 내 생각에는. 그래서 홀수는 0으로 생각함.
일단 점화식을 세우는 과정에서 각 개수마다의 고유한 모양이 있어야된다는 그 생각을 했어야함.
그래서 가장 먼저 뒤에서부터 n-2칸까지 채웠을 경우(dp[n-2])를 구하고, 나머지 2칸을 채울 수 있는 경우의 수인 3을 구한다.

그리고 2칸씩 늘려가면서 다음 경우의 수들에 대해서 계속 더해주면 되는건데
여기서 이해 안가는 점은 *2와 dp[0] = 1이라는 사실이다.
아무것도 놓지 않은 것을 1로는 삼을 수 없다는 점이 일단 걸리고, 
dp[0] = 1의 의미를 굳이 설명하자면, 고유한 값이라는 설정이라고 생각하면 될 것 같다.
4칸, 6칸, 8칸 짝수마다 특유의 고유한 문양을 만들 수가 있는데, 이 모양이 각각 2개씩이기 때문에
그것을 은유적으로 표현한 것이 아닌가 하는 생각이 든다.
그렇게 되면 *2 역시 이해가 가는게, 각 고유한 문양에 대해서 더하는 것을 표현한 거라면
우리가 맨 처음에 계산한것은 뒤에서부터 가로 길이가 i-2인만큼의 모든 경우의 수를 계산하였다. dp[i-2]*dp[2]로
그리고 가로 길이를 줄이면서, 나오는 고유한 문양에 대해서 나올 수 있는 경우를 *2 형식으로 표현한 것 같다.(모양이 2개이므로)

여튼 조금 더 이해해야하는 코드가 아닐까? 하는 생각이 든다.

