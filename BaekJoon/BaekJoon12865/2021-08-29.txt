1826번 연료 채우기

1km당 1L의 연료가 빠져나감.

시작부터 끝까지 중간 지점에 주유소가 있고
주유소를 최소한으로 들려서 도착하려고 할 때
주유소를 들리는 횟수를 구하라.

저번에 풀었던 문제와 비슷하다.
일단 타당한지부터 보겠다.

연료를 채울 곳은
가까운 거리에서 가장 많은 연료를 채울 수 있는 곳이다.
라고 생각했는데 거리의 느낌으로 정렬을 해서는 안되겠다는 생각을 했다.
2군데의 주유소가 있고, 2군데를 다 들리지 않으면 갈 수가 없는 상황이라고 생각해보자.
그럼, 내 알고리즘의 경우는 그 거리 내에 있는 연료가 많은 1군데만을 들린 후
연료가 없으니 더 이상 갈 수 없다고 말을 하게 된다.

그리디의 기준을 어디로 잡아줘야할까

일단 실패 조건은
한 지점에서 다른 지점으로까지 주유소 도달이 되지 않는 경우 // 
전체 기름이 갈 거리보다 작은 경우 // 거를 수 있음.

이번 문제는 다른 사람의 도움을 받아서 코드를 작성했다.
정확히는 실제 프로그래머스 같은 곳에서 코딩 테스트를 칠 때 Override하는 과정이 너무 귀찮아서
일부러 최대한 쓰지 않으려고 노력은 했는데
만약, 사용하게 된다면 이런 종류 말고는 없을 것 같다고도 생각했다.

우선순위 큐, 2차원 배열의 정렬 등이 필요한 경우는 흔히 2가지의 좌표를 받을 때가 가장 많다.
2가지의 좌표를 통해서 index와 해당하는 값으로 사용해도 되고,
반드시 2차원 배열로 받고 정렬이 필요한 경우는 Arrays.sort를 사용하게 되는데,
사실 2차원 배열을 Sort 시키는 과정은 거의 없다고 봐도 되지 않을까 싶다.
여튼, 만약 그런 상황이 오더라도, 어떠한 Class를 만들게 되면,
class A implements Comparator<A>
{
	@Override
	public int compareTo(A a)
	{
		return this.xxx - a.xxx;
	}
}
이렇게 Override 하나만 사용하고도, 손쉽게 정렬을 할 수 있게 되는 상황을 만들 수 있다는 것을
먼저 인지하고, 이번 문제를 살펴보자.

사실 기존에 해왔던 그리디 문제와 크게 다르지 않다.
내가 맨 처음 생각했던대로 연료의 크기 순으로 정렬을 하는 경우이고,
그것을 우선순위 큐에 넣어서 도달할 수 있는 거리에다가만 Queue의 요소를 빼게끔만 할 수 있으면
아주 손쉽게 풀리는 문제이다.
여기서 사용한 방법은 PriorityQueue를 사용해서, 거리가 작은 순으로 먼저 정렬한 후,
거리가 닿으면 또 다른 PriorityQueue에 연료가 많은 순대로 add해주면
손쉽게 풀리게 된다.
답이 도달할 수 없는 경우는 더 이상 갈 경로가 없어서
Queue가 비어버리는 경우가 된다.
그렇지만 않으면... 된다.


-----------------------------------------------------------------------------------------------------


1422번 숫자의 신

내 생각에는 예를 들어서
일단 감은 잡힌다. 결국 가장 큰 수를 최대한 쓰고
나머지 남은 수들을 1번씩만 사용하게 하면 된다.
1번씩 사용할 때 놓는 기준...
이게 문제다.

어떻게 놓아야할까
영역이 있다고 가정할 때, maxQue, minQue를 사용해서
기존과 동일하게 가되, 일단 그걸 앞에나 뒤에 놓았을 때
어느게 더 커지게 되는지...?

규칙이 중요한데
자리수를 통해서 규칙을 만들어내기도 힘들고,

정렬을 했을때 쉽게 풀리는 문제였다...?
그러니까 정렬을 할 때 애초에 두 숫자의 앞 뒤를 비교하면서
어떤 2개의 문자 a,b가 있을 때 이 a,b가 a+b, b+a 중 어느게 더 큰지를 비교해서
앞에다가 넣어주는 것이다.

예를 들어서

9 92 91 888888 7 78 76이 들어가있다고 하자.
여기서, 9와 888888을 비교했을 때, 9가 앞으로 들어가는 것이 더 크게 나오므로
9는 888888 앞에 있게 된다.
92와 888888 역시 마찬가지.

이런식으로 정렬이 되서 이렇게 나뉘어졌다고 했을 때
9와 92는 992 929 중 992가 더 크므로 92보다 9가 앞으로
92와 91은 9192보다 9291이 더 크므로 92가 앞으로
7와 76은 776 767 중에서 776이 더 크므로 7이 76보다 앞으로
78과 7은 787보다 778이 크므로 78이 더 앞으로 와서
결국 9 92 91 888888 78 7 76이 되게 된다.
그리고 이것이 이 문제의 정답이다.

나는 왜 앞 뒤로 비교하는 걸 눈치를 채고도, 이걸 정렬해본다는 생각을 한 적이 없을까.
아주 쉽게 풀 수 있는 문제였는데, 이걸 눈 앞에서 놓치는 상황이 좀 안타깝고,
화가 나야 정상인 상황 같다.
문제를 보고, 해볼 수 있는 방법은 다 해보자. 시도해보고 안되면 다르게 생각하면 되지 않을까.
