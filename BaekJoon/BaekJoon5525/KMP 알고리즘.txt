1. 일반 문자열과 비교할 비교 문자열을 만들어 냄

2. 비교 문자열에 대한 실패 함수의 결과값?을 도출해 냄
이 때, 비교 법은 KMP 알고리즘을 따름.

여기서 KMP 알고리즘은

대상과 비교 문자열을 같게 만든 후
1번째부터 살펴보며

맨 처음은
대상 문자열의 첫번째 값을 보고
이것이 같은지를 확인한다.
그 뒤, 이 문자열이 현재의 문자와 같지 않을 때까지
즉, i = 0 즉 첫번째 문자일 경우
j = 0, 비교 문자열의 첫번째 문자와 같을 경우
j의 위치를 오른쪽으로 1칸 옮기고, 원본 문자열 역시 1칸을 옮긴뒤
만약 같다면 계속 i와 j는 계속 ++을 유지하게 되고.
혹시 그 부분에서 달라지게 된다면, j 값은 비교 문자열에 대한 실패 함수에 대한 결과값을 통해
다음 위치로 넘어가게 된다.

만약 abbaba가 있고
대상 문자열이 baba라고 하자
그럼, i = 0, j = 0일때는 같지 않으므로 i만 1 올라가서
다시 b를 비교 하면 맞으므로
i = 1, j = 0인 상태에서 다시 비교할 것이다.
그럼 while문을 건너뛰고 같기 때문에 j < 3이 아니므로 넘어가게 되고, else에 따라 j가 1이 된다.
그리고 i = 2, j = 1이 된 상황에서 j > 1이고, while문의 규칙은 같아지지 않을 동안이므로
조건이 성립하여, j 값은 실패함수에 저장된 값이 된다. 이 때는 pi[0] 일텐데 이 값은 0이므로 j는 계속 0
즉, i = 2, j = 0이 될 것이다. 이 상황이 되면 현재 위치에 대한 문자가 b로 같으므로
i = 3, j = 1이 될 것이고, while문에서는 어? 얘네 같네 하고, while문을 넘긴다. 그 후 다시 if문 반복
그렇게 반복이 되다 보면, i = 5, j = 3가 될 것이고, 이때 j = 3이므로 현재의 j값은 pi[3]일때, 즉 2가 될 것이다.
이렇게 되면, 다음 문자열에서 ba만 나오게 되도, 사실 앞은 이미 ba라는 것이 입증되었다는 뜻이기 때문에
2칸을 건너 뛴 것이 된다.
그리고, count를 1 증가 시킨 후 i가 끝났으므로 끝나게 된다.

원리와 코드를 전부 일부는 이해한 것 같다.
