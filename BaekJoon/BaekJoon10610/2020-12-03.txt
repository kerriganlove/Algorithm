내가 볼 땐 다익스트라가 맞거든?

특정 지점-> 특정 지점으로 가는 최단 거리를 구하는 방식이므로 다익스트라 알고리즘은 맞음.
그러나 문제는 Cost, 이 Cost를 어떻게 처리할 것이냐.

결국은 DP가 답이었다.
생각대로 DP에서 비용에 대한 처리를 해주는 것이 맞았음.
DP 2차원 배열을 통해 1번에서 i번까지 가는 j만큼의 비용을 써서 간 시간.

다익스트라 알고리즘에서 Info class에 cost를 추가하여, distance를 2차원 배열로 선언 후
distance[i][j] => i번째까지 가는데 든 비용은 j고, 그 때 이동한 거리 = 배열값.
으로 선언한 뒤 여러 조건들을 달아 (도착지점에 도착하면 0, 그리고 정렬 조건 일부 수정)
(정해진 cost값에 대한 제한들을 많이 걸어둠)
아슬아슬하게 통과하였다.

1
5 5 4
1 2 2 1
2 3 2 1
3 5 2 1
1 3 1 5 ( runtime error 이걸로 해결 )

테스트 통과 완료 -> 다만, 거의 모든 아이디어를 계속 인터넷에서 보는 건 안 좋음.
쉬운건 내가 직접, 어렵다고 생각하는 것은 2시간 이상 고민 후 인터넷을 보고
아이디어만 참고하여 직접 코드 작성해보기.

-------------------------------------------------------------------------------------------------

10610
30의 배수를 출력하라.
단순하게 2*3*5의 형태이다.
즉, 10의 배수인 만큼 맨 뒷자리에 0이 들어갈 수 없는 숫자는
무조건 30의 배수를 만들 수 없다.
그럼 남은 숫자는 3, 3의 배수는 어떻게 만들까?
정수론에 의해서 3의 배수는 전체 숫자를 전부 더해도 3의 배수가 된다고 한다.
30의 배수 중 가장 큰 수를 만들려면 내림차순으로 정렬하는 것이 가장 크다.
그래서 String으로 받은 문자열을 char 배열로 만든 후 이를 오름차순으로 일단 변경하여
(내림차순을 할 수 있는 방법이 Arrays.sort에서는 잘 모르겠음.)
각 값을 모두 계산해준 뒤, 이를 StringBuilder를 활용하여 다시 내림차순으로 Sort된
문자열로 만들어주었다. 그리고 맨 뒷자리가 0이고, 각 값의 합이 3의 배수라면
현재의 문자열을 출력하도록 프로그램을 만들었다.
(여기서 알아야할 점. 3의 배수는 자기 자신의 자릿수를 모두 더해도 3의 배수이다.)
(정수론적인 관점이라면 한 번쯤 검색을 해보는 것 또한 좋다.)
