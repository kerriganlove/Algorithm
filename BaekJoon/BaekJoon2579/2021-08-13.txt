1003 피보나치 함수

일단 피보나치 함수를 그대로 구현해서 사용했는데 역시나 틀릴 줄 알았다.
이건 DP 문제고 아주 간단하게 풀 수 있는 문제였다.

이 역시 피보나치와 마찬가지로 그 전 두 값을 알면 dp[i-1] + dp[i-2]의 형태로 구할 수 있었다.
즉, dp[0]가 피보나치 함수에 0을 집어넣었을때 나오는 0과 1의 개수를 넣어둔 배열이라고 할 수 있다.
그런 식으로 했을 때
dp[2] 부터 계산이 가능해지며, 점화식은 dp[i] = dp[i-1] + dp[i-2]로 피보나치 배열과 같다.


----------------------------------------------------------------------------------------------------------

1463번 1로 만들기

기시감이 있던 문제여서 github를 뒤져보니 비슷한 다른 코드가 있었따.
일단 이 코드를 중심으로 설명을 하자면 이 코드는 2,3,5로 나누어 1로 만드는 과정인데
이 때 dp의 점화식은
dp[i] = dp[i-1]+1; 이다. 이는 1을 빼는 조건을 형상화한 것으로 보면 된다.
각각의 조건에 따라서 만약 조건을 만족할 시, 최솟값을 구하는 과정이므로, dp[i] = min(dp[i],dp[i/n]+1) 이 된다.
여기서 +1을 하는 이유는 i -> i/n으로 가게된다고 보기 때문. 즉, 지금 구한 dp값보다, i->i/n으로 내려가는 것이
더 적은 횟수인지 판단하는 것이다.


* DP의 핵심은 점화식을 어떻게 세울지 고민하는 것이다. 이게 너무나도 중요한 과정이고,
떠올리기가 쉽지 않기 때문에 많이 어렵다. 규칙성을 찾고, dp에 어떻게 적용해놓을지 꼭 많은 연습이 필요하다.


------------------------------------------------------------------------------------------------------------

2579번 계단 오르기

뭔가 경우의 수가 많은 지점이지만, 최대값을 구하는 과정.
내 생각에는 최대값이기 때문에 dp[i] 값은 그 계단을 오를 수 있는 최대값을 구하는 과정이 아닌가 싶다.
dp[1]은 첫번째 계단을 오를때의 최대거리인데

여기서 문제가 되는 점이 하나 있다.
연속된 세 개의 계단을 모두 밟아서는 안된다는 것. 즉 (1,2,3)과 같은 형태가 되지 않는다는 것이다.

일단 DFS를 활용해서 푼 거는 시간 초과다. 엉성하긴 하지만 답 자체는 반례 몇 개로 일단 증명된 것 같았고,
결국은 시간초과가 났으니 틀린거지만, 반례는 맞았으니 답은 구할 것이다.

문제는 시간 초관데, 그래서 DP를 제대로 활용할 줄 모르는 나는 도움을 받았고,
그 결과는 매우 단순했다.

세 계단을 연속해서 가지 못하기 때문에 마지막 도착의 경우의 수는 2가지이다.
마지막 전의 발판을 밟고 1칸을 올라가냐.
마지막 전전의 발판을 밟고 2칸을 올라가냐.

이 때, 1번의 경우는 당연스럽게도 마지막 전전의 발판은 밟고 올라가지 못한다.
그래서 dp의 점화식에서도 dp[n-2]의 경우를 고려하지 않는다.
그래서 마지막 전전전의 발판에서 2칸을 뛰어올라와야만 하므로, dp[n-3]에 자신의 점수를 더하는 방식이다.

2번의 경우는 그냥 dp[n-2]에서 dp[n-1]을 밟지 못하므로, 바로 2칸을 뛰어넘을 수 밖에 없는 것이다.

이렇게 풀게 되면 정답이 나온다. 그리고 여기서 느낀 점은, 제약 조건을 얼마나 점화식의 index로 잘 활용할 수 있는지
특히, 연속적인 수가 불가할 때는 이런식으로 만들 수 있다는 점을 배우게 된 것 같다.