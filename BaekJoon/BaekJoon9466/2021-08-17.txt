7569번 토마토(2?)

어제 풀었던 토마토가 3차원으로 돌아온 문제.
그냥 3차원 배열 선언하고, 똑같은 방법으로 돌렸음.
다른 사람들은 600ms대가 나오는데 나만 700ms가 나오는건
어떠한 디테일 차이 하나때문인것 같은데, 잘 모르겠음.
일단 디테일 중 하나인 익지 않는 토마토 개수가 0일때, 아예 BFS를 돌리지 않아도
답이 0이 나오게 한 건 20ms 정도 줄일 수 있었다.
앞으로도 고쳐나가야 할 불필요한 연산들을 깨달을 수 있는 시간이었다.

-----------------------------------------------------------------------------------------

9466번 텀 프로젝트

일단 생각해본 방법이 있긴 했는데, 맨 처음 idx에 대한 배열의 값을 어떻게 표현할지...? 그걸 모르겠음.
답은 맞는거 같은데 시간을 어떻게 획기적으로 줄일 수 있을지... 계속 79에서 걸리게 되는데
이때까지 해 온 애들을 check해야할 가치가 있다고 생각한다.

일단, 루트를 체크하는 건 맞았음. 그러나 그 루트를 체크하는 과정을 너무 꼬아서 생각한게 아닌가 하는 느낌이 있었음.
내가 기존에 했던 방식을 먼저 설명하면,
이건 하나의 경로를 나타내는 문제와도 같음. 즉, 시작점과 도착점이 있고, 루트를 이어 만들때,
마지막 점에서의 도착점이 최초 시작점과 같다면 그것은 하나의 루트로 인정이 된다.
이렇게 해석을 하면 된다.
그래서 시작점과 도착점이 같은 경우도 1가지의 경우로 치기 때문에, 이것을 미리 계산해둔 상태로 시작했다.
그 뒤, DFS에는 최초 시작점과 현재의 시작점을 줘서, 현재의 끝점과 최초 시작점이 같은지 항상 체크하고,
같다면 true를 반환해줘서 그 루트가 맞다는 것을 그냥 인정해버리고,
다르고, 만약 이미 팀이 있는 사람이었다면 false를 반환해서 이 루트가 전면적으로 틀렸다는 것을 증명했다.

이게 이론적으로는 무조건 맞는 말인데, 
함정이 있었다. 그게 뭐냐면 만약, 1번째부터 n-1까지 각각 자신의 앞점을 가리키는데
만약 이게 완성되지 않고, n이 자신 혼자 팀을 만들었다고 하면,
1->n-1까지 DFS 반복, 그 뒤 2->n-1까지 반복이 되서 O(N^2)가 나와버리는 상황이 발생하게 된다.
즉, 기존에 틀렸던 루트를 계속 반복하게 되면서 시간 초과가 나오는 상황이 나왔고,
이를 해결하기 위해서 많은 시간을 쏟아부었다.

처음에는 이 좌표들을 일일히 다 저장하거나, 현재 위치와 최종점을 저장해서 만약 이 최종점과 자신의 점이 같다면
하나의 루트로 인정한다는 식으로 해석해서 구현을 해봤으나 시간이 줄어들지 않았다.
그래서, 결국 답을 보게 되었고, 나는 이런 식으로 해석을 했다.

내 방법 역시 DFS 하는 빈도를 줄이기 위해서 이런 짓을 했었는데, 내가 간과한 부분이 하나 있었다.
for문의 활용이기도 한데, 그냥 만약 이 사람이 팀이 아니었고, 만약 끝점이 Route에 포함되어 있지 않다면
그 사람을 기점으로 끝나기 전까지의 새로운 루트를 하나 만들어낸다.
이렇게 되면 2 3 4 5 5의 루트를 예로 들어서 설명하면,
1번 학생부터 시작했을 때, 1,2,3,4까지는 이미 한 번 방문했고, 루트임을 증명했다.
그리고 2번 학생이 들어가게 되면 이미 자신은 Route에 포함이 됬었고, 그게 아니라는데 team인지 아닌지 증명해주는
배열에서 판독이 가능하므로, 더 이상 자신이 DFS 안에서 증명할 수 있는게 없게 되는 것이다.
이런 방법으로 시간을 줄여서 정답을 받은 것이었다.

다른 사람들은 COUNT 변수를 하나 써서 cnt를 받았는데, 나는 그냥 내가 원래 하던 방식을 고수하면서
그 사람들에게서 본 것들을 접목시켜서 답을 만들어냈다.

여기서 느낀건 저번 카카오 코딩테스트때도 그렇고, 나한테는 뭔가 답을 낼 수 있는 능력은 조금 있는데,
답을 내는 과정에서 생기는 예외사항들을 제대로 컨트롤해내지 못하는 것 같다.
저번 카카오도 최단 거리를 잘 찾고도, 그 하나의 제약을 몰라서 그 문제를 틀렸어야만 했다.
애초에 다익스트라를 쓰는게 아닐수도 있었겠지만...
여튼, 이런 식으로 어떤 알고리즘을 써서 푸는지는 아는데, 답을 도출해내기 위한 제약 사항에 대한 코드 변환을 좀 더
꼼꼼하게 체크하고, 시도해봐야한다고 생각한다. 이번 문제는 그런 깨달음을 얻게 해줄 수 있는 문제였다고 생각한다.